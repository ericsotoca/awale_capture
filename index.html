<!DOCTYPE html>
<!-- lang attribute will be set dynamically by JS -->
<html lang="fr">
<head>
    <!-- Manifeste web standard -->
    <link rel="manifest" href="/manifest.json">
   
    <!-- Balises sp√©cifiques √† iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Dans la T√™te d'un Champion">
    <link rel="apple-touch-icon" href="/icons/icon-152x152.png">
   
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Title will be set dynamically by JS -->
    <title>Dans la T√™te d'un Champion</title>
    <style>
        /* Styles CSS (Identiques - Aucune modification n√©cessaire ici) */
        html, body { height: 100%; margin: 0; padding: 0; box-sizing: border-box; }
        body { display: flex; flex-direction: column; justify-content: flex-start; align-items: center; min-height: 100vh; padding: 10px 0; transition: background-color 0.3s, color 0.3s; font-family: sans-serif; overflow-x: hidden; }
        *, *:before, *:after { box-sizing: inherit; }
        .dark-mode { background-color: #333; color: #fff; }
        .dark-mode .hole { color: #fff; }
        .dark-mode #bet-pot-info, .dark-mode #success-rate { background-color: #555; border-color: #777; color: #fff; }
        .dark-mode #title, .dark-mode #move-info, .dark-mode #played-moves, .dark-mode #result, .dark-mode #turn-indicator { color: #fff; }
        .dark-mode #help-modal, .dark-mode #secret-modal, .dark-mode #comment-modal, .dark-mode #history-modal, .dark-mode #premium-info-modal { background: #444; color: #fff; }
        .dark-mode .history-entry summary { background-color: #555; }
        .dark-mode .history-entry { border-color: #777; }
        .dark-mode .hole.player1-hole { background-color: #a0522d; color: white; }
        .dark-mode .hole.player2-hole { background-color: #5c4033; color: white; }
        .dark-mode .selected-bet { animation: blink-dark 0.6s infinite; }
        .dark-mode #turn-indicator.player-turn { color: #90ee90; background-color: #385038; }
        .dark-mode #turn-indicator.opponent-turn { color: #ffa0a0; background-color: #5a3030; }
        .dark-mode .comment-entry::before, .dark-mode .error-entry::before { color: #bbb; }
        .dark-mode .comment-options { color: #ddd; }
        .dark-mode .error-detail { color: #ff6b6b;}
        .dark-mode #theme-toggle { background: url('https://img.icons8.com/ios-filled/24/ffffff/light-off.png') no-repeat center; background-size: 60%; }
        .dark-mode .highlight-capture-enabled { animation: blink-orange-dark 0.6s infinite; }
        .dark-mode .highlight-pressure-enabled { border: 3px dashed #ff8c00 !important; box-shadow: 0 0 8px #ff8c00; }
        .dark-mode #cross-toggle-btn { background: #555; border-color: #777; color: #ff6b6b; }
        .dark-mode .highlight-start { background-color: rgba(0, 200, 255, 0.5) !important; }
        #game-area { width: 90vw; max-width: 700px; padding: 1vh 5px; box-sizing: border-box; display: flex; flex-direction: column; align-items: center; gap: 1vh; margin-top: 10px; }
        #title { color: #333; text-align: center; font-size: clamp(1.4em, 5vw, 1.8em); margin: 0 0 0.5vh 0; user-select: none; cursor: help; }
        #turn-indicator { font-weight: bold; margin-bottom: 8px; text-align: center; padding: 5px; border-radius: 4px; min-height: 1.2em; width: 90%; max-width: 300px; }
        #turn-indicator.player-turn { color: #006400; background-color: #e8f5e9; }
        #turn-indicator.opponent-turn { color: #b71c1c; background-color: #ffebee; }
        .button-yellow, .button-next, .button-small, .button-save, .button-copy, .button-reset, .button-close { padding: 10px 18px; font-size: clamp(0.9em, 2.5vw, 1em); border-radius: 5px; cursor: pointer; transition: transform 0.2s, background-color 0.2s; border: none; font-weight: bold; margin: 5px 4px; white-space: nowrap; }
        .button-yellow:active, .button-next:active { transform: scale(0.95); }
        .button-yellow { background-color: #ffc107; color: #000; border: 2px solid #e0a800; }
        .button-yellow:hover { background-color: #e0a800; }
        .button-next { background-color: #28a745; color: white; border: 2px solid #218838; }
        .button-next:hover { background-color: #218838; }
        .button-small { background-color: #17a2b8; color: white; border: 2px solid #138496; padding: 8px 12px; font-size: clamp(0.8em, 2.2vw, 0.9em); }
        .button-small:hover { background-color: #138496; }
        .button-small.history { background-color: #6f42c1; border: 2px solid #5a32a3; }
        .button-small.history:hover { background-color: #5a32a3; }
        .button-save { background-color: #28a745; color: white; border: 2px solid #218838; }
        .button-save:hover { background-color: #218838; }
        .button-copy { background-color: #007bff; color: white; border: 2px solid #0056b3; }
        .button-copy:hover { background-color: #0056b3; }
        .button-reset { background-color: #dc3545; color: white; border: 2px solid #c82333; }
        .button-reset:hover { background-color: #c82333; }
        .button-close { background-color: #6c757d; color: white; border: 2px solid #5a6268; }
        .button-close:hover { background-color: #5a6268; }
        .logo-container { display: flex; align-items: center; justify-content: center; gap: 10px; margin: 1vh auto; flex-direction: column; }
        .logo-row { display: flex; align-items: center; gap: clamp(10px, 3vw, 20px); }
        .logo { width: clamp(100px, 25vw, 150px); height: auto; }
        #theme-toggle, #help-btn { width: clamp(30px, 8vw, 40px); height: clamp(30px, 8vw, 40px); border-radius: 50%; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; background-color: #eee; }
        #theme-toggle { background: url('https://img.icons8.com/ios-filled/24/000000/light-on.png') no-repeat center; background-size: 60%;}
        #help-btn { background-color: #007bff; color: white; font-size: clamp(1em, 4vw, 1.4em); font-weight: bold; }
        #cross-toggle-btn { color: red; font-weight: bold; font-size: clamp(1.8em, 7vw, 2.4em); line-height: 1; padding: 0 5px 4px 5px; background: #eee; border: 1px solid #ccc; border-radius: 50%; width: clamp(30px, 8vw, 40px); height: clamp(30px, 8vw, 40px); cursor: pointer; display: flex; align-items: center; justify-content: center; user-select: none; }
        .selector-container { display: flex; justify-content: center; gap: clamp(10px, 4vw, 25px); margin: 1.5vh 0; flex-wrap: wrap; }
        .selector-container > div { display: flex; align-items: center; gap: 5px;}
        .selector-container label, .selector-container select { font-size: clamp(0.85em, 2.8vw, 1em); }
        #board { position: relative; width: 100%; display: flex; flex-direction: column; align-items: center; margin: 1vh 0; padding: 5px 0; box-sizing: border-box; border: 1px solid #eee; background-color: #f9f9f9; border-radius: 8px; }
        .dark-mode #board { border: 1px solid #555; background-color: #404040; }
        .board-row { display: flex; justify-content: center; width: 100%; padding: 0 5px; box-sizing: border-box; }
        .board-label { flex: 0 0 auto; width: 13vw; max-width: 70px; height: auto; margin: 0.5vw; display: flex; justify-content: center; align-items: center; font-weight: bold; font-size: clamp(0.8em, 3vw, 1.3em); text-align: center; color: #666; user-select: none; }
        .dark-mode .board-label { color: #ccc; }
        .hole { flex: 0 0 auto; width: 13vw; height: 13vw; max-width: 70px; max-height: 70px; color: black; display: flex; align-items: center; justify-content: center; border-radius: 50%; margin: 0.5vw; font-weight: bold; font-size: clamp(1em, 4vw, 1.8em); transition: background-color 0.3s, box-shadow 0.3s, border 0.2s, color 0.3s; box-sizing: border-box; border: 2px solid transparent; position: relative; overflow: hidden; cursor: default; user-select: none; }
        .hole.player1-hole { background-color: #d2b48c; color: #333; }
        .hole.player2-hole { background-color: #8b4513; color: white; }
        .hole.player1-hole.clickable { cursor: pointer; }
        .hole.disabled { cursor: not-allowed !important; opacity: 0.7; }
        .highlight-incorrect { border: 3px solid red !important; box-shadow: 0 0 10px red; }
        .highlight-correct { border: 3px solid limegreen !important; box-shadow: 0 0 10px limegreen; }
        .highlight-start { background-color: rgba(0, 200, 255, 0.7) !important; }
        .highlight-end { background-color: rgba(210, 180, 222, 0.7) !important; }
        .selected-bet { animation: blink 0.6s infinite; }
        @keyframes blink { 0%, 100% { background-color: #4682b4; border-color: #1e90ff; box-shadow: 0 0 8px #1e90ff; } 50% { background-color: #add8e6; border-color: #4682b4; box-shadow: 0 0 12px #4682b4; } }
        @keyframes blink-dark { 0%, 100% { background-color: #1e90ff; border-color: #4682b4; box-shadow: 0 0 8px #4682b4; } 50% { background-color: #4682b4; border-color: #1e90ff; box-shadow: 0 0 12px #1e90ff;} }
        .highlight-capture-enabled { animation: blink-orange 0.6s infinite; }
        @keyframes blink-orange { 0%, 100% { background-color: #ffcc80; border: 2px solid orange; box-shadow: 0 0 6px orange; } 50% { background-color: #ffa726; border: 2px solid darkorange; box-shadow: 0 0 10px darkorange; } }
        @keyframes blink-orange-dark { 0%, 100% { background-color: #e69500; border: 2px solid #ff8c00; box-shadow: 0 0 6px #ff8c00; } 50% { background-color: #ffae42; border: 2px solid #ffa500; box-shadow: 0 0 10px #ffa500; } }
        .highlight-pressure-enabled { border: 3px dashed orange !important; box-shadow: 0 0 8px orange; }
        .dark-mode .highlight-pressure-enabled { border: 3px dashed #ff8c00 !important; box-shadow: 0 0 8px #ff8c00; }
        #red-cross { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: none; justify-content: center; align-items: center; overflow: hidden; }
        .cross-line { position: absolute; background-color: transparent; opacity: 0.7; }
        .cross-line.horizontal { width: 96%; height: 2px; top: 50%; left: 2%; transform: translateY(-50%); border-top: 2px dashed red; }
        .cross-line.vertical { width: 2px; height: 90%; left: 50%; top: 5%; transform: translateX(-50%); border-left: 2px dashed red; }
        #move-info { text-align: center; margin-bottom: 5px; font-size: clamp(0.9em, 3vw, 1.1em);}
        .pot-container { display: flex; align-items: center; justify-content: center; gap: clamp(8px, 3vw, 15px); margin: 1vh 0; }
        #bet-pot-info, #success-rate { background-color: #fff3cd; border: 1px solid #e0a800; padding: 6px 12px; border-radius: 5px; display: inline-block; text-align: center; font-size: clamp(0.85em, 2.8vw, 1em);}
        #played-moves { text-align: center; margin-top: 5px; font-size: clamp(0.8em, 2.5vw, 0.9em); color: #555; width: 90%; word-wrap: break-word;}
        .dark-mode #played-moves { color: #ccc; }
        #result { text-align: center; font-weight: bold; min-height: 1.2em; margin: 8px 0; font-size: clamp(0.95em, 3.2vw, 1.1em); }
        .betting-area { margin-top: 1.5vh; display: flex; flex-direction: column; align-items: center; gap: 10px; width: 100%; }
        .bet-selection { display: flex; align-items: center; justify-content: center; gap: 5px; flex-wrap: wrap; margin-bottom: 10px; }
        .bet-selection label, .bet-selection select, .bet-selection span { font-size: clamp(0.9em, 2.8vw, 1em); }
        .bet-buttons { display: flex; justify-content: center; align-items: center; gap: clamp(5px, 2vw, 10px); flex-wrap: wrap; }
        #help-modal, #secret-modal, #comment-modal, #history-modal, #premium-info-modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); z-index: 1000; max-width: 90%; width: 500px; max-height: 85vh; overflow-y: auto; }
        #help-modal button, #secret-modal button, #comment-modal button, #history-modal button:not(.history-buttons button), #premium-info-modal button { margin-top: 15px; }
        #comment-modal { height: auto; /* Removed min-height */ } /* Adjusted comment modal height */
        .comment-section { display: flex; flex-direction: column; gap: 10px; width: 100%; }
        #comment-input { width: calc(100% - 10px); height: 60px; resize: vertical; padding: 5px; margin-bottom: 5px; border: 1px solid #ccc;} /* Reduced textarea height */
        .checkbox-section { margin-top: 5px; column-count: 2; column-gap: 15px; } /* Added columns */
        .checkbox-section label { display: flex; align-items: center; margin-bottom: 6px; cursor: pointer; break-inside: avoid-column; } /* Prevent breaking inside columns */
        .checkbox-section input[type="checkbox"] { margin-right: 8px;}
        #history-content { margin-bottom: 10px; font-family: monospace; }
        .history-buttons { display: flex; justify-content: space-between; gap: 10px; margin-top: 15px; flex-wrap: wrap; }
        .history-entry { border: 1px solid #ddd; border-radius: 5px; margin-bottom: 10px; background-color: #f9f9f9; }
        .history-entry summary { padding: 10px; font-weight: bold; cursor: pointer; background-color: #eee; border-radius: 5px 5px 0 0; outline: none; display: flex; justify-content: space-between; align-items: center;}
        .history-entry summary::before { content: '‚ñ∂ '; display: inline-block; margin-right: 5px; transition: transform 0.2s; order: -1;}
        .history-entry summary::-webkit-details-marker { display: none; }
        .history-entry[open] summary::before { transform: rotate(90deg); }
        .history-details { padding: 10px; border-top: 1px solid #ddd; }
        .history-details h4 { margin-top: 0; margin-bottom: 5px; font-size: 1em; }
        .comment-entry, .error-entry { margin-bottom: 8px; padding-left: 15px; position: relative; font-size: 0.9em; line-height: 1.4; word-break: break-word; }
        .comment-entry::before, .error-entry::before { content: '‚Ä¢'; position: absolute; left: 0; color: #555; }
        .comment-options { font-style: italic; color: #333; margin-left: 5px; }
        .error-detail { color: #c00; font-weight: bold;}
        .confetti { position: fixed; width: 8px; height: 8px; pointer-events: none; animation: fall 3s ease-out forwards; border-radius: 50%; transform: rotate(0deg); z-index: 9999; }
        @keyframes fall { 0% { transform: translateY(-10vh) rotate(0deg); opacity: 1; } 100% { transform: translateY(100vh) rotate(720deg); opacity: 0; } }
        #premium-info-modal ul { list-style: disc; margin-left: 25px; margin-top: 10px;}
        #premium-info-modal li { margin-bottom: 8px; }
        #help-modal ul { list-style: disc; margin-left: 25px; margin-top: 10px;}
        #help-modal li { margin-bottom: 8px; }
        @media (max-width: 480px) {
            body { padding: 5px 0; }
            #game-area { width: 95vw; gap: 0.8vh;}
            .logo-row { gap: 10px; }
            .button-yellow, .button-next, .button-small { padding: 8px 10px; font-size: 0.9em; margin: 3px; }
            .bet-buttons { gap: 5px; }
            .history-buttons { justify-content: center; }
            .pot-container { gap: 8px; }
            #bet-pot-info, #success-rate { padding: 5px 8px; }
            #help-modal, #secret-modal, #comment-modal, #history-modal, #premium-info-modal { width: 95%; max-height: 80vh; }
            .hole, .board-label { width: 14vw; max-width: 60px; height: 14vw; max-height: 60px; margin: 0.4vw; font-size: clamp(0.9em, 3.5vw, 1.6em); }
            .checkbox-section { column-count: 1; } /* Single column on smaller screens */
        }
    </style>
</head>
<body>
    <!-- Structure HTML (Identique) -->
     <div class="logo-container">
        <div id="secret-message"></div>
        <div class="logo-row">
            <img src="logo.jpg" alt="Logo" class="logo" onerror="this.style.display='none'">
            <button id="theme-toggle"></button>
            <button id="help-btn">i</button>
            <button id="cross-toggle-btn">+</button>
        </div>
    </div>
    <div class="selector-container">
        <div>
            <label for="language-select" id="language-label"></label>
            <select id="language-select" onchange="updateLanguage()">
                <option value="fr">Fran√ßais</option>
                <option value="en">English</option>
                <option value="es">Espa√±ol</option>
                <option value="ru">–†—É—Å—Å–∫–∏–π</option>
                <option value="zh">‰∏≠Êñá</option>
            </select>
        </div>
        <div>
            <label for="level-select" id="level-label"></label>
            <select id="level-select" onchange="changeLevel()"></select>
        </div>
    </div>
    <div id="game-area">
        <h1 id="title"></h1>
        <div id="turn-indicator"></div>
        <div id="board">
            <div class="board-row"> <div class="board-label">f</div><div class="board-label">e</div><div class="board-label">d</div><div class="board-label">c</div><div class="board-label">b</div><div class="board-label">a</div> </div>
            <div id="player2-row" class="board-row"></div>
            <div id="player1-row" class="board-row"></div>
            <div class="board-row"> <div class="board-label">A</div><div class="board-label">B</div><div class="board-label">C</div><div class="board-label">D</div><div class="board-label">E</div><div class="board-label">F</div> </div>
            <div id="red-cross"> <div class="cross-line horizontal"></div> <div class="cross-line vertical"></div> </div>
        </div>
        <div id="move-info"></div>
        <div class="pot-container">
            <div id="bet-pot-info"></div>
            <div id="success-rate"></div>
        </div>
        <div id="played-moves"></div>
        <div id="result"></div>
        <div class="betting-area">
            <div class="bet-selection">
                <label id="bet-label" for="bet-amount"></label>
                <select id="bet-amount">
                    <option value="25">25 %</option>
                    <option value="50">50 %</option>
                    <option value="75">75 %</option>
                    <option value="100">100 %</option>
                </select>
                <span>‚Ç¨</span>
                <label id="bet-case-label" for="bet-input"></label>
                <select id="bet-input">
                    <option value="A">A</option><option value="B">B</option><option value="C">C</option>
                    <option value="D">D</option><option value="E">E</option><option value="F">F</option>
                </select>
            </div>
            <div class="bet-buttons">
                <button id="bet-and-verify-btn" class="button-yellow" onclick="betAndVerify()"></button>
                <button id="next-btn" class="button-next" onclick="moveNext()"></button>
                <button id="record-btn" class="button-small" onclick="openCommentModal()" style="display: none;"></button>
                <button id="history-btn" class="button-small history" onclick="openHistoryModal()" style="display: none;"></button>
            </div>
        </div>
    </div>
    <!-- Modals (structure identique) -->
     <div id="help-modal">
        <h2 id="help-title"></h2>
        <div id="help-text"></div>
        <button onclick="closeModal('help-modal')" class="button-close" id="help-modal-close"></button>
    </div>
    <div id="secret-modal">
        <h2 id="secret-tips-title"></h2>
        <ul id="secret-tips"></ul>
        <button onclick="closeModal('secret-modal')" class="button-close" id="secret-modal-close"></button>
    </div>
    <div id="comment-modal">
        <h3 id="comment-title"></h3>
        <div class="comment-section">
            <textarea id="comment-input" placeholder=""></textarea>
             <div class="checkbox-section">
                 <!-- Les "value" sont utilis√©s comme cl√©s pour la traduction -->
                 <label><input type="checkbox" name="comment-option" value="CaseToStudy"> <span class="checkbox-label-text">Cas √† √©tudier</span></label>
 <label><input type="checkbox" name="comment-option" value="NoSeedsBC"> <span class="checkbox-label-text">Aucune graines en case B et C</span></label>
                 <label><input type="checkbox" name="comment-option" value="OffensiveOverDefensive"> <span class="checkbox-label-text">Etre Offensif (capture) > D√©fensif (√©chapp√©)</span></label>
                 <label><input type="checkbox" name="comment-option" value="BuildKrouOffensive"> <span class="checkbox-label-text">Construire Krou Offensif (D/E/F) > D√©fensif</span></label>
                 <label><input type="checkbox" name="comment-option" value="BuildKrouDefensive"> <span class="checkbox-label-text">Construire Krou D√©fensif (C/D/E) > Offensif</span></label>
                 <label><input type="checkbox" name="comment-option" value="BlockOpponentKrou"> <span class="checkbox-label-text">Bloquer le Contre-Krou Adverse</span></label>
                 <label><input type="checkbox" name="comment-option" value="BuildTwoKrous"> <span class="checkbox-label-text">Construire 2 Krous en m√™me temps</span></label>
                 <label><input type="checkbox" name="comment-option" value="MultiCaptureLimit3"> <span class="checkbox-label-text">Capture multiple limit√© √† 3 cases</span></label>
                 <label><input type="checkbox" name="comment-option" value="MultiCaptureMax5"> <span class="checkbox-label-text">Capture multiple max (5 cases)</span></label>
                 <label><input type="checkbox" name="comment-option" value="SpeedUpGame"> <span class="checkbox-label-text">Acc√©l√©rer le jeu</span></label>
                 <label><input type="checkbox" name="comment-option" value="SlowDownGame"> <span class="checkbox-label-text">Ralentir le jeu</span></label>
                
            </div>
        </div>
        <div style="text-align: center; margin-top: 20px;">
            <button class="button-save" onclick="saveComment()" id="comment-save-btn"></button>
            <button class="button-close" onclick="closeModal('comment-modal')" id="comment-cancel-btn"></button>
        </div>
    </div>
    <div id="history-modal">
        <h3 id="history-title"></h3>
        <div id="history-content"></div>
        <div class="history-buttons">
            <button class="button-copy" onclick="copyHistoryContent()" id="history-copy-btn"></button>
            <button class="button-reset" onclick="resetHistory()" id="history-reset-btn"></button>
            <button class="button-close" onclick="closeModal('history-modal')" id="history-close-btn"></button>
        </div>
    </div>
    <div id="premium-info-modal">
        <h2 id="premium-modal-title"></h2>
        <p id="premium-modal-text"></p>
        <p><strong id="premium-modal-benefits-title"></strong></p>
        <ul>
            <li id="premium-benefit-levels"></li>
            <li id="premium-benefit-history"></li>
            <li id="premium-benefit-record"></li>
            <li id="premium-benefit-aids"></li>
            <li id="premium-benefit-cross"></li>
            <li id="premium-benefit-secrets"></li>
        </ul>
        <p id="premium-modal-howto"></p>
        <p style="text-align: center; margin-top:15px;">
            <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer" class="button-yellow" style="text-decoration: none;" id="premium-modal-action-link"></a>
        </p>
        <button onclick="closeModal('premium-info-modal')" class="button-close" id="premium-modal-close"></button>
    </div>
    <script>
        // !!! LOGIQUE DE JEU MISE A JOUR !!!
        // simulateMove ne modifie plus l'√©tat global directement.
        // finalizeGameRecord est appel√© depuis betAndVerify et moveNext si fin de partie.
        // --- Variables Globales (Identiques + highlightDisabled) ---
        let isPremium = false;
        let areAidesEnabled = false;
        let isCrossVisible = false;
        let highlightDisabled = false; // Nouvelle variable pour d√©sactiver la surbrillance
        const initialBoard = () => ({ player1: [4, 4, 4, 4, 4, 4], player2: [4, 4, 4, 4, 4, 4] });
        const initialScores = () => ({ player1: 0, player2: 0 });
        let board = {};
        let scores = {};
        const games = [ "FfCdAbBaDbCdDcBdAaBbDcCdDeEeDdCfEeFdBeFaD", "FfBaCfAbAfBdCfBcAfCeBfDfCeBdCeEfDbEcAdCaEbF", "FfBaCaAaCfBbAcCaBbCcAfAdAfCaBeDfEeBfAaEbCaEbF", "FfCcBbAaFaDaAcBdDbCfDaCdBcDbCcAeFdBeCfFaCbDaFbE", "FfBdBfDdAbAdDaBdDbAfAeAbDaBbDcEeDdBfAeCfEaDbEcBdF", "FfCcBbAcBbFaCfCeCcBbDfAcDdCfEfBeAfDbEcCdEeAaDbEcBdCeDfEaAbF", "FfBcEeBcDcCcEbAeDbCcBaEfDeEdEcDbCaEdDcEbFfEdFfAaBbCeAcCdDeBf", "FfCcBbAfFdAaEaFaCaEbBeEcCdAfEeCbDdAfAeAfEaCbBbEaDcAdCbEcDdEeAfFfCdBeAfDaE", "FfBaCbBdFbDbFdCfCcFdDfFaCdDcBdDbEfFbAaEdFaCaDfFaAcAeEaAdDbEeCdEfCcEeFbAcDfAeAfEdBcDaCbF", "FfCbDeDcCbAfAeFfAcDbEfFeCcDaAcEdCcEdDaEbBdDbCcAdBeBcEcDfDdCeAcDdBbEbFfEeBfCaFaAeCbBcCdEeAfD", "FfCbDbFbBeAfCcAaDaCeDbBdBcDaEeDfEaCaBbAcCdBeEfDaAbBcEdCeDfEaFfEeDdCcBeDdCeDfFaEaBbCcDdAeBfEaF", "FfCaFdBcFdDaFaBdAfFeFfDcCdDeBbBaDcAfAdAeCbAfDcAdBeCfFbAcDdEeBfFbDaCcDdEeAaFaBbDcEdCeDfFaBbCcAdBeCf", "FfBaCbBeDbCfCeDaBcCfDeEfAcDaBeEfCdAaEcDbAfAeAdBcCeEdDeFfEaDbCdBeAcCdBeCfFbEaDcBeAdCaFaEeBbDcCdDeEaF", "FfBcFbBdAeBbCcAdDbCeDdCeDaFaBaEeBfFbEdBfFeDfEbFaAfAaCeAfEbDcEeFaDbCeEdCcDfDeCdDeEfFaBaDbCcAdBeDfFaEaAbBcCdDeEaFfAaBbCcDdEeFf", "FfCcBbAfFdDfCdDcAdBbDcCeDcAbCaEfBdDcEeBdFcCbEaBdDfCcEbDcBeAcEdAbDcFfEaAeAcCdDbEeBdEcDeCdDeFaEaFfCbBdDaAeAcCeEfFd" ];
        let currentGame = [];
        let currentMoveIndex = -1;
        let moveHistory = [];
        let currentBet = null;
        let playedMoves = [];
        let betAmount = 0;
        let pot = 100;
        let currentLanguage = "fr"; // Default language
        let successfulBets = 0;
        let totalPlayer1Bets = 0;
        let isBetLocked = false;
        let lockedBetPercentage = null;
        let isSuccessGuaranteed = false;
        let perfectGamesCount = 0;
        let currentGameIndex = 0;
        let gameStartTime = null;
        let errorLog = [];
        let lastIncorrectGuess = null;
        let lastCorrectMove = null;
        let highlightStartHole = null;
        let highlightEndHole = null;
        let animationTimeout = null;
        let gameRecords = [];
        let currentGameRecord = {};
        const holeMap = { 'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5 };
        const opponentHoleCodes = ['a', 'b', 'c', 'd', 'e', 'f'];
        const playerHoleCodes = ['A', 'B', 'C', 'D', 'E', 'F'];
        let isGameOver = { confettiShown: false };
        // --- Objet Translations (AJOUT des nouvelles options de commentaire + highlight messages) ---
        const translations = {
             fr: {
                 pageTitle: "Dans la T√™te d'un Champion",
                 languageLabel: "Langue :",
                 levelLabel: "Partie :",
                 title: "Dans la T√™te d'un Champion !",
                 moveInfo: (p1, p2) => `Joueur üòä ‚Üì: ${p1} | Joueur üòî ‚Üë: ${p2}`,
                 betPotInfo: (pot) => `Cagnotte:<BR>${pot} ‚Ç¨`,
                 successRate: (rate) => `R√©ussite:<BR>${rate} %`,
                 playedMoves: (index, total, moves) => `${index} / ${total} | Derniers jeux: ${moves}`,
                 betLabel: "Je mise",
                 betCaseLabel: "sur",
                 betButton: "Je parie !",
                 nextButton: "Suivant",
                 recordButtonShort: "Enr",
                 historyButtonShort: "Histo",
                 closeButton: "Fermer",
                 saveButton: "Sauver",
                 cancelButton: "Annuler",
                 copyButton: "Copier (JSON)",
                 resetButton: "Reset",
                 tooltipPot: "Votre argent virtuel actuel",
                 tooltipSuccessRate: "Pourcentage de paris corrects sur cette partie",
                 tooltipRecord: "Enregistrer un commentaire pour ce coup (Premium)",
                 tooltipHistory: "Voir l'historique des parties jou√©es (Premium)",
                 tooltipHelp: "Afficher l'aide / R√®gles",
                 tooltipTheme: "Mode Sombre/Clair",
                 tooltipCross: "Options Premium (Croix / Aides)",
                 resultInvalidBet: "Mise invalide !",
                 resultWin: "Gagn√© !",
                 resultLose: "Perdu !",
                 resultGameOver: "Partie termin√©e !",
                 resetMessage: "Jeu r√©initialis√© !",
                 premiumUnlockedMessage: "Version Premium activ√©e ! Fonctionnalit√©s d√©bloqu√©es.",
                 successOnMessage: "Succ√®s garanti ACTIV√â",
                 successOffMessage: "Succ√®s garanti D√âSACTIV√â",
                 betLockedMessage: (pct) => `Mise verrouill√©e (${pct}%)`,
                 betUnlockedMessage: "Mise d√©verrouill√©e",
                 backMessage: "Retour arri√®re effectu√©",
                 opponentTurnMessage: "Clic Suivant (tour adverse)",
                 playerTurnIndicator: "√Ä vous : S√©lectionnez & misez !",
                 opponentTurnIndicator: "Tour adverse (Clic Suivant)",
                 emptyHoleMessage: "Case vide !",
                 notYourTurnMessage: "Pas votre tour ! Cliquez sur 'Suivant'.",
                 invalidHoleMessage: "Case invalide ou vide !",
                 internalErrorMessage: "Erreur interne de simulation.",
                 aidesEnabled: "Aides visuelles activ√©es",
                 aidesDisabled: "Aides visuelles d√©sactiv√©es",
                 crossEnabled: "Croix rouge activ√©e",
                 crossDisabled: "Croix rouge d√©sactiv√©e",
                 highlightDisabledMsg: "Surbrillance d√©sactiv√©e (captures d'√©cran neutres)",
                 highlightEnabledMsg: "Surbrillance r√©activ√©e",
                 errorDisplayMessage: "Erreur d'affichage. Rechargez.",
                 confirmResetHistory: "Voulez-vous vraiment r√©initialiser tout l'historique ? Cette action est irr√©versible.",
                 historyResetSuccess: "Historique r√©initialis√© !",
                 copySuccess: "Contenu de l'historique copi√© !",
                 copyError: "Erreur lors de la copie.",
                 copyPrepareError: "Erreur lors de la pr√©paration de la copie.",
                 noHistory: "Aucun historique de partie enregistr√©.",
                 helpTitle: "Aide & Objectif",
                 helpTextStandard: `<strong>Bienvenue dans l'entra√Ænement c√©r√©bral Awal√© !</strong><br><br>Votre objectif est de <strong>penser comme un champion</strong> en devinant le coup qu'il a jou√© dans une partie r√©elle √† chaque fois que c'est votre tour (Joueur üòä ‚Üì).<br><br><strong>Comment jouer :</strong><br>1. Choisissez une langue et l'une des 3 premi√®res parties disponibles.<br>2. Quand c'est votre tour (üòä ‚Üì), observez le plateau.<br>3. Cliquez sur une de vos cases (A-F) contenant des graines pour la s√©lectionner.<br>4. Choisissez le pourcentage de votre cagnotte virtuelle √† miser sur ce choix.<br>5. Cliquez sur 'Je parie !'. Si votre choix est correct, vous gagnez votre mise. Sinon, vous la perdez.<br>6. Quand c'est le tour de l'adversaire (üòî ‚Üë), cliquez sur 'Suivant'.<br><br><strong>Passez √† la Version Premium !</strong><br>Pour une exp√©rience compl√®te et soutenir notre association, adh√©rez √† <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer">Jeux Nomades France</a>. La version Premium d√©bloque les fonctionnalit√©s suivantes :<ul><li>L'acc√®s √† <strong>toutes les parties</strong> d'entra√Ænement.</li><li>Les boutons <strong>"Histo"</strong> (historique) et <strong>"Enr"</strong> (prise de notes).</li><li>L'activation des <strong>aides visuelles</strong> (indications de capture/pression).</li><li>L'activation de la <strong>croix rouge</strong> d'alignement.</li><li>L'acc√®s aux <strong>astuces secr√®tes</strong>.</li></ul>`,
                 helpTextPremium: `<strong>Bienvenue dans la version Premium !</strong><br><br>Vous avez acc√®s √† toutes les fonctionnalit√©s pour vous entra√Æner √† penser comme un champion.<br><br><strong>Fonctionnalit√©s Premium :</strong><br><ul><li><strong>Toutes les Parties :</strong> Acc√©dez √† l'ensemble des parties via le s√©lecteur.</li><li><strong>Historique ("Histo") :</strong> Consultez vos parties pr√©c√©dentes, statistiques et commentaires.</li><li><strong>Coaching par IA via Export JSON :</strong> Utilisez le bouton "Copier (JSON)" dans l'historique. Collez le texte copi√© dans une Intelligence Artificielle conversationnelle (comme ChatGPT, Gemini, Mistral, etc.). Le prompt inclus demandera √† l'IA d'analyser vos parties (erreurs, commentaires) et de vous donner des conseils de coaching personnalis√©s, directement dans la langue s√©lectionn√©e dans l'application !</li><li><strong>Enregistrement ("Enr") :</strong> Ajoutez des notes strat√©giques √† chaque coup jou√©.</li><li><strong>Aides Visuelles :</strong><ul><li>Activation/D√©sactivation : Appui long (3s) sur le bouton <strong>+</strong> en haut √† droite.</li><li>Case adverse orange clignotante : Votre coup s√©lectionn√© capture directement.</li><li>Case adverse avec bordure orange : Pression pour capture future possible.</li><li>Votre case avec bordure orange pointill√©e : Menace de capture par l'adversaire.</li></ul></li><li><strong>Croix Rouge :</strong><ul><li>Activation/D√©sactivation : Clic simple sur le bouton <strong>+</strong> en haut √† droite.</li><li>Aide √† visualiser les alignements de cases.</li></ul></li></ul><strong>Astuces Secr√®tes Activables :</strong><br><ul><li><strong>Logo x3 clics :</strong> R√©initialise la partie en cours.</li><li><strong>Cagnotte x3 clics :</strong> Active/D√©sactive le mode "Succ√®s Garanti" (tous les paris r√©ussissent).</li><li><strong>Texte "Je mise" x3 clics :</strong> Verrouille/D√©verrouille le pourcentage de mise s√©lectionn√©.</li><li><strong>Case 'a' adverse (appui 2s) :</strong> Annule le dernier coup jou√© (retour arri√®re).</li><li><strong>Cases 'f' + 'a' adverses (appui 3s simultan√©) :</strong> Affiche la liste des astuces secr√®tes.</li></ul>`,
                 secretMessage: "Bonjour",
                 secretTipsTitle: "Astuces Secr√®tes (Premium)",
                 secretTips: [ "Logo x3 clics : Reset partie", "Cagnotte x3 clics : Succ√®s garanti ON/OFF", "'Je mise' x3 clics : Verrouille/D√©verrouille mise (%)", "Case 'f' adverse (appui 2s) : Bonjour", "Case 'a' adverse (appui 2s) : R√©v√®le le prochain coup", "Cases 'f' + 'a' adverses (appui 3s simultan√©) : Montre cette liste" ],
 revealNextMoveMessage: (move) => `Prochain coup : ${move}`,
                 commentModalTitle: "Ajouter un Commentaire",
                 commentInputPlaceholder: "Votre note strat√©gique ici...",
                 // START: Added translations for new comment options (fr)
                 commentOptNoSeedsBC: "Aucune graines en case B et C",
                 commentOptOffensiveOverDefensive: "Etre Offensif (capture) > D√©fensif (√©chapp√©)",
                 commentOptBuildKrouOffensive: "Construire Krou Offensif (D/E/F) > D√©fensif",
                 commentOptBuildKrouDefensive: "Construire Krou D√©fensif (C/D/E) > Offensif",
                 commentOptBlockOpponentKrou: "Bloquer le Contre-Krou Adverse",
                 commentOptBuildTwoKrous: "Construire 2 Krous en m√™me temps",
                 commentOptMultiCaptureLimit3: "Capture multiple limit√© √† 3 cases",
                 commentOptMultiCaptureMax5: "Capture multiple max (5 cases)",
                 commentOptSpeedUpGame: "Acc√©l√©rer le jeu",
                 commentOptSlowDownGame: "Ralentir le jeu",
                 commentOptCaseToStudy: "Cas √† √©tudier",
                 // END: Added translations for new comment options (fr)
                 historyTitle: "Historique des Parties",
                 historyRecordTitle: (name, date) => `Partie: ${name} (${date})`,
                 historyStats: (rate, pot, duration) => `R√©ussite: ${rate}% | Pot final: ${pot}‚Ç¨ | Dur√©e: ${duration}s`,
                 historyCommentsTitle: "Commentaires Enregistr√©s",
                 historyErrorsTitle: "Erreurs de Pari",
                 historyNoComments: "Aucun commentaire enregistr√© pour cette partie.",
                 historyNoErrors: "Aucune erreur de pari enregistr√©e pour cette partie.",
                 historyInProgress: "(En cours)",
                 historyMoveLabel: "Coup",
                 historyBetErrorLabel: (bet, correct, potChange, date) => `Pari√© <span class="error-detail">${bet}</span> vs <span class="error-detail">${correct}</span> (Pot ${potChange > 0 ? '+' : ''}${potChange}‚Ç¨) <small>(${date})</small>`,
                 premiumModalTitle: "Fonctionnalit√© Premium",
                 premiumModalText: "Cette fonctionnalit√©, ainsi que d'autres avantages, sont r√©serv√©s aux membres Premium.",
                 premiumModalBenefitsTitle: "Avantages Premium :",
                 premiumBenefitLevels: "Acc√®s √† toutes les parties d'entra√Ænement.",
                 premiumBenefitHistory: "Bouton 'Histo' pour voir et analyser vos parties pr√©c√©dentes.",
                 premiumBenefitRecord: "Bouton 'Enr' pour ajouter des commentaires strat√©giques.",
                 premiumBenefitAids: "Activation des aides visuelles (captures/pression).",
                 premiumBenefitCross: "Activation de la croix rouge d'alignement.",
                 premiumBenefitSecrets: "Acc√®s aux astuces secr√®tes.",
                 premiumModalHowto: "Pour d√©bloquer la version Premium et soutenir notre association, devenez membre de <strong>Jeux Nomades France</strong> :",
                 premiumModalActionLink: "Adh√©rer √† l'association",
                 gameDropdownFormat: (index, moves) => `Partie ${index} (${moves} coups)`,
                 encouragingMessages: [ "Bravo!", "Super!", "Excellent!", "Continue!", "Impressionnant!", "Magnifique!", "Dou√©!", "Formidable!", "Incroyable!", "G√©nial!", "Parfait!", "√âpoustouflant!", "√âtoile montante!", "Sensationnel!", "Triomphe!", "Ma√Ætre!", "L√©gendaire!", "G√©nie!", "Champion!", "Immortel!" ]
             },
              en: {
                 pageTitle: "Inside the Mind of a Champion",
                 languageLabel: "Language:",
                 levelLabel: "Game:",
                 title: "Inside the Mind of a Champion!",
                 moveInfo: (p1, p2) => `Player üòä ‚Üì: ${p1} | Player üòî ‚Üë: ${p2}`,
                 betPotInfo: (pot) => `Pot:<BR>${pot} ‚Ç¨`,
                 successRate: (rate) => `Success:<BR>${rate} %`,
                 playedMoves: (index, total, moves) => `${index} / ${total} | Last plays: ${moves}`,
                 betLabel: "I bet",
                 betCaseLabel: "on",
                 betButton: "Place Bet!",
                 nextButton: "Next",
                 recordButtonShort: "Rec",
                 historyButtonShort: "Hist",
                 closeButton: "Close",
                 saveButton: "Save",
                 cancelButton: "Cancel",
                 copyButton: "Copy (JSON)",
                 resetButton: "Reset",
                 tooltipPot: "Your current virtual money",
                 tooltipSuccessRate: "Percentage of correct bets in this game",
                 tooltipRecord: "Record a comment for this move (Premium)",
                 tooltipHistory: "View history of played games (Premium)",
                 tooltipHelp: "Show Help / Rules",
                 tooltipTheme: "Dark/Light Mode",
                 tooltipCross: "Premium Options (Cross / Aids)",
                 resultInvalidBet: "Invalid bet!",
                 resultWin: "Won!",
                 resultLose: "Lost!",
                 resultGameOver: "Game over!",
                 resetMessage: "Game reset!",
                 premiumUnlockedMessage: "Premium Version activated! Features unlocked.",
                 successOnMessage: "Guaranteed Success ON",
                 successOffMessage: "Guaranteed Success OFF",
                 betLockedMessage: (pct) => `Bet locked (${pct}%)`,
                 betUnlockedMessage: "Bet unlocked",
                 backMessage: "Undo successful",
                 opponentTurnMessage: "Click Next (opponent's turn)",
                 playerTurnIndicator: "Your turn: Select & bet!",
                 opponentTurnIndicator: "Opponent's turn (Click Next)",
                 emptyHoleMessage: "Empty hole!",
                 notYourTurnMessage: "Not your turn! Click 'Next'.",
                 invalidHoleMessage: "Invalid or empty hole!",
                 internalErrorMessage: "Internal simulation error.",
                 aidesEnabled: "Visual aids enabled",
                 aidesDisabled: "Visual aids disabled",
                 crossEnabled: "Red cross enabled",
                 crossDisabled: "Red cross disabled",
                 highlightDisabledMsg: "Highlight disabled (neutral screenshots)",
                 highlightEnabledMsg: "Highlight enabled",
                 errorDisplayMessage: "Display error. Please reload.",
                 confirmResetHistory: "Are you sure you want to reset the entire history? This action is irreversible.",
                 historyResetSuccess: "History reset!",
                 copySuccess: "History content copied!",
                 copyError: "Error copying.",
                 copyPrepareError: "Error preparing copy.",
                 noHistory: "No game history recorded.",
                 helpTitle: "Help & Objective",
                 helpTextStandard: `<strong>Welcome to Awale Brain Training!</strong><br><br>Your goal is to <strong>think like a champion</strong> by guessing the move they played in a real game each time it's your turn (Player üòä ‚Üì).<br><br><strong>How to play:</strong><br>1. Choose a language and one of the first 3 available games.<br>2. When it's your turn (üòä ‚Üì), observe the board.<br>3. Click on one of your holes (A-F) containing seeds to select it.<br>4. Choose the percentage of your virtual pot to bet on this choice.<br>5. Click 'Place Bet!'. If your choice is correct, you win your bet. Otherwise, you lose it.<br>6. When it's the opponent's turn (üòî ‚Üë), click 'Next'.<br><br><strong>Upgrade to Premium!</strong><br>For a complete experience and to support our association, join <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer">Jeux Nomades France</a>. The Premium version unlocks the following features:<ul><li>Access to <strong>all training games</strong>.</li><li>The <strong>"Hist"</strong> (history) and <strong>"Rec"</strong> (record notes) buttons.</li><li>Activation of <strong>visual aids</strong> (capture/pressure indicators).</li><li>Activation of the <strong>red alignment cross</strong>.</li><li>Access to <strong>secret tips</strong>.</li></ul>`,
                 helpTextPremium: `<strong>Welcome to the Premium version!</strong><br><br>You have access to all features to train yourself to think like a champion.<br><br><strong>Premium Features:</strong><br><ul><li><strong>All Games:</strong> Access all games via the selector.</li><li><strong>History ("Hist"):</strong> Review your past games, statistics, and comments.</li><li><strong>AI Coaching via JSON Export:</strong> Use the "Copy (JSON)" button in the history. Paste the copied text into a conversational AI (like ChatGPT, Gemini, Mistral, etc.). The included prompt will ask the AI to analyze your games (errors, comments) and give you personalized coaching advice, directly in the language selected in the app!</li><li><strong>Recording ("Rec"):</strong> Add strategic notes to each move played.</li><li><strong>Visual Aids:</strong><ul><li>Activation/Deactivation: Long press (3s) the <strong>+</strong> button at the top right.</li><li>Flashing orange opponent hole: Your selected move captures directly.</li><li>Opponent hole with orange border: Pressure for possible future capture.</li><li>Your hole with dashed orange border: Threat of capture by the opponent.</li></ul></li><li><strong>Red Cross:</strong><ul><li>Activation/Deactivation: Single click the <strong>+</strong> button at the top right.</li><li>Helps visualize hole alignments.</li></ul></li></ul><strong>Activatable Secret Tips:</strong><br><ul><li><strong>Logo x3 clicks:</strong> Resets the current game.</li><li><strong>Pot x3 clicks:</strong> Toggles "Guaranteed Success" mode (all bets win).</li><li><strong>"I bet" text x3 clicks:</strong> Locks/Unlocks the selected bet percentage.</li><li><strong>Opponent 'a' hole (2s press):</strong> Undoes the last move played.</li><li><strong>Opponent 'f' + 'a' holes (3s simultaneous press):</strong> Shows the secret tips list.</li></ul>`,
                 secretMessage: "Hello",
                 secretTipsTitle: "Secret Tips (Premium)",
                 secretTips: [ "Logo x3 clicks: Reset game", "Pot x3 clicks: Guaranteed Success ON/OFF", "'I bet' x3 clicks: Lock/Unlock bet (%)", "Opponent 'f' hole (2s press): Hello", "Opponent 'a' hole (2s press): Reveal next move", "Opponent 'f' + 'a' holes (3s simultaneous press): Show this list" ],
 revealNextMoveMessage: (move) => `Next move: ${move}`,
                 commentModalTitle: "Add a Comment",
                 commentInputPlaceholder: "Your strategic note here...",
                 // START: Added translations for new comment options (en)
                 commentOptNoSeedsBC: "No seeds in holes B and C",
                 commentOptOffensiveOverDefensive: "Be Offensive (capture) > Defensive (escape)",
                 commentOptBuildKrouOffensive: "Build Offensive Krou (D/E/F) > Defensive",
                 commentOptBuildKrouDefensive: "Build Defensive Krou (C/D/E) > Offensive",
                 commentOptBlockOpponentKrou: "Block Opponent's Counter-Krou",
                 commentOptBuildTwoKrous: "Build 2 Krous at the same time",
                 commentOptMultiCaptureLimit3: "Multiple capture limited to 3 holes",
                 commentOptMultiCaptureMax5: "Max multiple capture (5 holes)",
                 commentOptSpeedUpGame: "Speed up the game",
                 commentOptSlowDownGame: "Slow down the game",
                 commentOptCaseToStudy: "Case to study",
                 // END: Added translations for new comment options (en)
                 historyTitle: "Game History",
                 historyRecordTitle: (name, date) => `Game: ${name} (${date})`,
                 historyStats: (rate, pot, duration) => `Success: ${rate}% | Final Pot: ${pot}‚Ç¨ | Duration: ${duration}s`,
                 historyCommentsTitle: "Recorded Comments",
                 historyErrorsTitle: "Betting Errors",
                 historyNoComments: "No comments recorded for this game.",
                 historyNoErrors: "No betting errors recorded for this game.",
                 historyInProgress: "(In Progress)",
                 historyMoveLabel: "Move",
                 historyBetErrorLabel: (bet, correct, potChange, date) => `Bet <span class="error-detail">${bet}</span> vs <span class="error-detail">${correct}</span> (Pot ${potChange > 0 ? '+' : ''}${potChange}‚Ç¨) <small>(${date})</small>`,
                 premiumModalTitle: "Premium Feature",
                 premiumModalText: "This feature, along with other benefits, is reserved for Premium members.",
                 premiumModalBenefitsTitle: "Premium Benefits:",
                 premiumBenefitLevels: "Access to all training games.",
                 premiumBenefitHistory: "'Hist' button to view and analyze your past games.",
                 premiumBenefitRecord: "'Rec' button to add strategic comments.",
                 premiumBenefitAids: "Activation of visual aids (captures/pressure).",
                 premiumBenefitCross: "Activation of the red alignment cross.",
                 premiumBenefitSecrets: "Access to secret tips.",
                 premiumModalHowto: "To unlock the Premium version and support our association, become a member of <strong>Jeux Nomades France</strong>:",
                 premiumModalActionLink: "Join the association",
                 gameDropdownFormat: (index, moves) => `Game ${index} (${moves} moves)`,
                 encouragingMessages: [ "Bravo!", "Great!", "Excellent!", "Keep it up!", "Impressive!", "Magnificent!", "Skilled!", "Wonderful!", "Incredible!", "Awesome!", "Perfect!", "Breathtaking!", "Rising Star!", "Sensational!", "Triumph!", "Master!", "Legendary!", "Genius!", "Champion!", "Immortal!" ]
             },
              es: {
                 pageTitle: "En la Mente de un Campe√≥n",
                 languageLabel: "Idioma:",
                 levelLabel: "Partida:",
                 title: "¬°En la Mente de un Campe√≥n!",
                 moveInfo: (p1, p2) => `Jugador üòä ‚Üì: ${p1} | Jugador üòî ‚Üë: ${p2}`,
                 betPotInfo: (pot) => `Pozo:<BR>${pot} ‚Ç¨`,
                 successRate: (rate) => `√âxito:<BR>${rate} %`,
                 playedMoves: (index, total, moves) => `${index} / ${total} | √öltimas jugadas: ${moves}`,
                 betLabel: "Apuesto",
                 betCaseLabel: "a",
                 betButton: "¬°Apostar!",
                 nextButton: "Siguiente",
                 recordButtonShort: "Grabar",
                 historyButtonShort: "Histo",
                 closeButton: "Cerrar",
                 saveButton: "Guardar",
                 cancelButton: "Cancelar",
                 copyButton: "Copiar (JSON)",
                 resetButton: "Reset",
                 tooltipPot: "Tu dinero virtual actual",
                 tooltipSuccessRate: "Porcentaje de apuestas correctas en esta partida",
                 tooltipRecord: "Grabar un comentario para esta jugada (Premium)",
                 tooltipHistory: "Ver el historial de partidas jugadas (Premium)",
                 tooltipHelp: "Mostrar Ayuda / Reglas",
                 tooltipTheme: "Modo Oscuro/Claro",
                 tooltipCross: "Opciones Premium (Cruz / Ayudas)",
                 resultInvalidBet: "¬°Apuesta inv√°lida!",
                 resultWin: "¬°Ganado!",
                 resultLose: "¬°Perdido!",
                 resultGameOver: "¬°Partida terminada!",
                 resetMessage: "¬°Juego reiniciado!",
                 premiumUnlockedMessage: "¬°Versi√≥n Premium activada! Funcionalidades desbloqueadas.",
                 successOnMessage: "√âxito garantizado ACTIVADO",
                 successOffMessage: "√âxito garantizado DESACTIVADO",
                 betLockedMessage: (pct) => `Apuesta bloqueada (${pct}%)`,
                 betUnlockedMessage: "Apuesta desbloqueada",
                 backMessage: "Deshacer realizado",
                 opponentTurnMessage: "Clic Siguiente (turno del oponente)",
                 playerTurnIndicator: "Tu turno: ¬°Selecciona y apuesta!",
                 opponentTurnIndicator: "Turno del oponente (Clic Siguiente)",
                 emptyHoleMessage: "¬°Casilla vac√≠a!",
                 notYourTurnMessage: "¬°No es tu turno! Haz clic en 'Siguiente'.",
                 invalidHoleMessage: "¬°Casilla inv√°lida o vac√≠a!",
                 internalErrorMessage: "Error interno de simulaci√≥n.",
                 aidesEnabled: "Ayudas visuales activadas",
                 aidesDisabled: "Ayudas visuales desactivadas",
                 crossEnabled: "Cruz roja activada",
                 crossDisabled: "Cruz roja desactivada",
                 highlightDisabledMsg: "Resaltado desactivado (capturas neutras)",
                 highlightEnabledMsg: "Resaltado activado",
                 errorDisplayMessage: "Error de visualizaci√≥n. Recarga.",
                 confirmResetHistory: "¬øEst√°s seguro de que quieres reiniciar todo el historial? Esta acci√≥n es irreversible.",
                 historyResetSuccess: "¬°Historial reiniciado!",
                 copySuccess: "¬°Contenido del historial copiado!",
                 copyError: "Error al copiar.",
                 copyPrepareError: "Error al preparar la copia.",
                 noHistory: "No hay historial de partidas guardado.",
                 helpTitle: "Ayuda y Objetivo",
                 helpTextStandard: `<strong>¬°Bienvenido al entrenamiento cerebral Awal√©!</strong><br><br>Tu objetivo es <strong>pensar como un campe√≥n</strong> adivinando la jugada que hizo en una partida real cada vez que sea tu turno (Jugador üòä ‚Üì).<br><br><strong>C√≥mo jugar:</strong><br>1. Elige un idioma y una de las 3 primeras partidas disponibles.<br>2. Cuando sea tu turno (üòä ‚Üì), observa el tablero.<br>3. Haz clic en una de tus casillas (A-F) que contenga semillas para seleccionarla.<br>4. Elige el porcentaje de tu pozo virtual a apostar por esta elecci√≥n.<br>5. Haz clic en '¬°Apostar!'. Si tu elecci√≥n es correcta, ganas tu apuesta. Si no, la pierdes.<br>6. Cuando sea el turno del oponente (üòî ‚Üë), haz clic en 'Siguiente'.<br><br><strong>¬°P√°sate a la Versi√≥n Premium!</strong><br>Para una experiencia completa y apoyar a nuestra asociaci√≥n, √∫nete a <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer">Jeux Nomades France</a>. La versi√≥n Premium desbloquea las siguientes funcionalidades:<ul><li>Acceso a <strong>todas las partidas</strong> de entrenamiento.</li><li>Los botones <strong>"Histo"</strong> (historial) y <strong>"Grabar"</strong> (toma de notas).</li><li>Activaci√≥n de las <strong>ayudas visuales</strong> (indicaciones de captura/presi√≥n).</li><li>Activaci√≥n de la <strong>cruz roja</strong> de alineaci√≥n.</li><li>Acceso a los <strong>trucos secretos</strong>.</li></ul>`,
                 helpTextPremium: `<strong>¬°Bienvenido a la versi√≥n Premium!</strong><br><br>Tienes acceso a todas las funcionalidades para entrenarte a pensar como un campe√≥n.<br><br><strong>Funcionalidades Premium:</strong><br><ul><li><strong>Todas las Partidas:</strong> Accede a todas las partidas mediante el selector.</li><li><strong>Historial ("Histo"):</strong> Consulta tus partidas anteriores, estad√≠sticas y comentarios.</li><li><strong>Coaching por IA v√≠a Exportar JSON:</strong> Utiliza el bot√≥n "Copiar (JSON)" en el historial. Pega el texto copiado en una Inteligencia Artificial conversacional (como ChatGPT, Gemini, Mistral, etc.). El prompt incluido le pedir√° a la IA que analice tus partidas (errores, comentarios) y te d√© consejos de coaching personalizados, ¬°directamente en el idioma seleccionado en la aplicaci√≥n!</li><li><strong>Grabaci√≥n ("Grabar"):</strong> A√±ade notas estrat√©gicas a cada jugada realizada.</li><li><strong>Ayudas Visuales:</strong><ul><li>Activaci√≥n/Desactivaci√≥n: Pulsaci√≥n larga (3s) en el bot√≥n <strong>+</strong> arriba a la derecha.</li><li>Casilla del oponente naranja parpadeante: Tu jugada seleccionada captura directamente.</li><li>Casilla del oponente con borde naranja: Presi√≥n para posible captura futura.</li><li>Tu casilla con borde naranja discontinuo: Amenaza de captura por el oponente.</li></ul></li><li><strong>Cruz Roja:</strong><ul><li>Activaci√≥n/Desactivaci√≥n: Clic simple en el bot√≥n <strong>+</strong> arriba a la derecha.</li><li>Ayuda a visualizar las alineaciones de casillas.</li></ul></li></ul><strong>Trucos Secretos Activables:</strong><br><ul><li><strong>Logo x3 clics:</strong> Reinicia la partida actual.</li><li><strong>Pozo x3 clics:</strong> Activa/Desactiva el modo "√âxito Garantizado" (todas las apuestas ganan).</li><li><strong>Texto "Apuesto" x3 clics:</strong> Bloquea/Desbloquea el porcentaje de apuesta seleccionado.</li><li><strong>Casilla 'a' del oponente (pulsaci√≥n 2s):</strong> Deshace la √∫ltima jugada realizada.</li><li><strong>Casillas 'f' + 'a' del oponente (pulsaci√≥n 3s simult√°nea):</strong> Muestra la lista de trucos secretos.</li></ul>`,
                 secretMessage: "Hola",
                 secretTipsTitle: "Trucos Secretos (Premium)",
                 secretTips: [ "Logo x3 clics: Reset partida", "Pozo x3 clics: √âxito garantizado ON/OFF", "'Apuesto' x3 clics: Bloquear/Desbloquear apuesta (%)", "Casilla 'f' oponente (pulsaci√≥n 2s): Hola", "Casilla 'a' oponente (pulsaci√≥n 2s): Revela la pr√≥xima jugada", "Casillas 'f' + 'a' oponentes (pulsaci√≥n 3s simult√°nea): Muestra esta lista" ],
 revealNextMoveMessage: (move) => `Pr√≥xima jugada: ${move}`,
                 commentModalTitle: "A√±adir un Comentario",
                 commentInputPlaceholder: "Tu nota estrat√©gica aqu√≠...",
                 // START: Added translations for new comment options (es)
                 commentOptNoSeedsBC: "Sin semillas en casillas B y C",
                 commentOptOffensiveOverDefensive: "Ser Ofensivo (captura) > Defensivo (escape)",
                 commentOptBuildKrouOffensive: "Construir Krou Ofensivo (D/E/F) > Defensivo",
                 commentOptBuildKrouDefensive: "Construir Krou Defensivo (C/D/E) > Ofensivo",
                 commentOptBlockOpponentKrou: "Bloquear el Contra-Krou Adversario",
                 commentOptBuildTwoKrous: "Construir 2 Krous al mismo tiempo",
                 commentOptMultiCaptureLimit3: "Captura m√∫ltiple limitada a 3 casillas",
                 commentOptMultiCaptureMax5: "Captura m√∫ltiple m√°x. (5 casillas)",
                 commentOptSpeedUpGame: "Acelerar el juego",
                 commentOptSlowDownGame: "Ralentizar el juego",
                 commentOptCaseToStudy: "Caso a estudiar",
                 // END: Added translations for new comment options (es)
                 historyTitle: "Historial de Partidas",
                 historyRecordTitle: (name, date) => `Partida: ${name} (${date})`,
                 historyStats: (rate, pot, duration) => `√âxito: ${rate}% | Pozo final: ${pot}‚Ç¨ | Duraci√≥n: ${duration}s`,
                 historyCommentsTitle: "Comentarios Guardados",
                 historyErrorsTitle: "Errores de Apuesta",
                 historyNoComments: "No hay comentarios guardados para esta partida.",
                 historyNoErrors: "No hay errores de apuesta guardados para esta partida.",
                 historyInProgress: "(En curso)",
                 historyMoveLabel: "Jugada",
                 historyBetErrorLabel: (bet, correct, potChange, date) => `Apostado <span class="error-detail">${bet}</span> vs <span class="error-detail">${correct}</span> (Pozo ${potChange > 0 ? '+' : ''}${potChange}‚Ç¨) <small>(${date})</small>`,
                 premiumModalTitle: "Funcionalidad Premium",
                 premiumModalText: "Esta funcionalidad, junto con otros beneficios, est√° reservada para miembros Premium.",
                 premiumModalBenefitsTitle: "Beneficios Premium:",
                 premiumBenefitLevels: "Acceso a todas las partidas de entrenamiento.",
                 premiumBenefitHistory: "Bot√≥n 'Histo' para ver y analizar tus partidas anteriores.",
                 premiumBenefitRecord: "Bot√≥n 'Grabar' para a√±adir comentarios estrat√©gicos.",
                 premiumBenefitAids: "Activaci√≥n de ayudas visuales (capturas/presi√≥n).",
                 premiumBenefitCross: "Activaci√≥n de la cruz roja de alineaci√≥n.",
                 premiumBenefitSecrets: "Acceso a trucos secretos.",
                 premiumModalHowto: "Para desbloquear la versi√≥n Premium y apoyar a nuestra asociaci√≥n, hazte miembro de <strong>Jeux Nomades France</strong>:",
                 premiumModalActionLink: "Unirse a la asociaci√≥n",
                 gameDropdownFormat: (index, moves) => `Partida ${index} (${moves} jugadas)`,
                 encouragingMessages: [ "¬°Bravo!", "¬°Genial!", "¬°Excelente!", "¬°Sigue as√≠!", "¬°Impresionante!", "¬°Magn√≠fico!", "¬°H√°bil!", "¬°Maravilloso!", "¬°Incre√≠ble!", "¬°Asombroso!", "¬°Perfecto!", "¬°Impresionante!", "¬°Estrella en ascenso!", "¬°Sensacional!", "¬°Triunfo!", "¬°Maestro!", "¬°Legendario!", "¬°Genio!", "¬°Campe√≥n!", "¬°Inmortal!" ]
             },
             ru: {
                 pageTitle: "–í –£–º–µ –ß–µ–º–ø–∏–æ–Ω–∞",
                 languageLabel: "–Ø–∑—ã–∫:",
                 levelLabel: "–ò–≥—Ä–∞:",
                 title: "–í –£–º–µ –ß–µ–º–ø–∏–æ–Ω–∞!",
                 moveInfo: (p1, p2) => `–ò–≥—Ä–æ–∫ üòä ‚Üì: ${p1} | –ò–≥—Ä–æ–∫ üòî ‚Üë: ${p2}`,
                 betPotInfo: (pot) => `–ë–∞–Ω–∫:<BR>${pot} ‚Ç¨`,
                 successRate: (rate) => `–£—Å–ø–µ—Ö:<BR>${rate} %`,
                 playedMoves: (index, total, moves) => `${index} / ${total} | –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Ö–æ–¥—ã: ${moves}`,
                 betLabel: "–°—Ç–∞–≤–∫–∞",
                 betCaseLabel: "–Ω–∞",
                 betButton: "–°–¥–µ–ª–∞—Ç—å —Å—Ç–∞–≤–∫—É!",
                 nextButton: "–°–ª–µ–¥—É—é—â–∏–π",
                 recordButtonShort: "–ó–∞–ø",
                 historyButtonShort: "–ò—Å—Ç",
                 closeButton: "–ó–∞–∫—Ä—ã—Ç—å",
                 saveButton: "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
                 cancelButton: "–û—Ç–º–µ–Ω–∞",
                 copyButton: "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å (JSON)",
                 resetButton: "–°–±—Ä–æ—Å",
                 tooltipPot: "–í–∞—à–∏ —Ç–µ–∫—É—â–∏–µ –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ –¥–µ–Ω—å–≥–∏",
                 tooltipSuccessRate: "–ü—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö —Å—Ç–∞–≤–æ–∫ –≤ —ç—Ç–æ–π –∏–≥—Ä–µ",
                 tooltipRecord: "–ó–∞–ø–∏—Å–∞—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ —ç—Ç–æ–º—É —Ö–æ–¥—É (–ü—Ä–µ–º–∏—É–º)",
                 tooltipHistory: "–ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Å—ã–≥—Ä–∞–Ω–Ω—ã—Ö –∏–≥—Ä (–ü—Ä–µ–º–∏—É–º)",
                 tooltipHelp: "–ü–æ–∫–∞–∑–∞—Ç—å –°–ø—Ä–∞–≤–∫—É / –ü—Ä–∞–≤–∏–ª–∞",
                 tooltipTheme: "–¢–µ–º–Ω—ã–π/–°–≤–µ—Ç–ª—ã–π —Ä–µ–∂–∏–º",
                 tooltipCross: "–ü—Ä–µ–º–∏—É–º –û–ø—Ü–∏–∏ (–ö—Ä–µ—Å—Ç / –ü–æ–º–æ—â—å)",
                 resultInvalidBet: "–ù–µ–≤–µ—Ä–Ω–∞—è —Å—Ç–∞–≤–∫–∞!",
                 resultWin: "–í—ã–∏–≥—Ä–∞–ª!",
                 resultLose: "–ü—Ä–æ–∏–≥—Ä–∞–ª!",
                 resultGameOver: "–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!",
                 resetMessage: "–ò–≥—Ä–∞ —Å–±—Ä–æ—à–µ–Ω–∞!",
                 premiumUnlockedMessage: "–ü—Ä–µ–º–∏—É–º –í–µ—Ä—Å–∏—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞! –§—É–Ω–∫—Ü–∏–∏ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.",
                 successOnMessage: "–ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –£—Å–ø–µ—Ö –í–ö–õ",
                 successOffMessage: "–ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –£—Å–ø–µ—Ö –í–´–ö–õ",
                 betLockedMessage: (pct) => `–°—Ç–∞–≤–∫–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞ (${pct}%)`,
                 betUnlockedMessage: "–°—Ç–∞–≤–∫–∞ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞",
                 backMessage: "–•–æ–¥ –æ—Ç–º–µ–Ω–µ–Ω",
                 opponentTurnMessage: "–ù–∞–∂–º–∏—Ç–µ –°–ª–µ–¥—É—é—â–∏–π (—Ö–æ–¥ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞)",
                 playerTurnIndicator: "–í–∞—à —Ö–æ–¥: –í—ã–±–µ—Ä–∏—Ç–µ –∏ —Å–¥–µ–ª–∞–π—Ç–µ —Å—Ç–∞–≤–∫—É!",
                 opponentTurnIndicator: "–•–æ–¥ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–ù–∞–∂–º–∏—Ç–µ –°–ª–µ–¥—É—é—â–∏–π)",
                 emptyHoleMessage: "–ü—É—Å—Ç–∞—è –ª—É–Ω–∫–∞!",
                 notYourTurnMessage: "–ù–µ –≤–∞—à —Ö–æ–¥! –ù–∞–∂–º–∏—Ç–µ '–°–ª–µ–¥—É—é—â–∏–π'.",
                 invalidHoleMessage: "–ù–µ–≤–µ—Ä–Ω–∞—è –∏–ª–∏ –ø—É—Å—Ç–∞—è –ª—É–Ω–∫–∞!",
                 internalErrorMessage: "–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–∏–º—É–ª—è—Ü–∏–∏.",
                 aidesEnabled: "–í–∏–∑—É–∞–ª—å–Ω–∞—è –ø–æ–º–æ—â—å –≤–∫–ª—é—á–µ–Ω–∞",
                 aidesDisabled: "–í–∏–∑—É–∞–ª—å–Ω–∞—è –ø–æ–º–æ—â—å –≤—ã–∫–ª—é—á–µ–Ω–∞",
                 crossEnabled: "–ö—Ä–∞—Å–Ω—ã–π –∫—Ä–µ—Å—Ç –≤–∫–ª—é—á–µ–Ω",
                 crossDisabled: "–ö—Ä–∞—Å–Ω—ã–π –∫—Ä–µ—Å—Ç –≤—ã–∫–ª—é—á–µ–Ω",
                 highlightDisabledMsg: "–ü–æ–¥—Å–≤–µ—Ç–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞ (–Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–µ —Å–∫—Ä–∏–Ω—à–æ—Ç—ã)",
                 highlightEnabledMsg: "–ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤–∫–ª—é—á–µ–Ω–∞",
                 errorDisplayMessage: "–û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ.",
                 confirmResetHistory: "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–±—Ä–æ—Å–∏—Ç—å –≤—Å—é –∏—Å—Ç–æ—Ä–∏—é? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ.",
                 historyResetSuccess: "–ò—Å—Ç–æ—Ä–∏—è —Å–±—Ä–æ—à–µ–Ω–∞!",
                 copySuccess: "–°–æ–¥–µ—Ä–∂–∏–º–æ–µ –∏—Å—Ç–æ—Ä–∏–∏ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!",
                 copyError: "–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è.",
                 copyPrepareError: "–û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –∫ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—é.",
                 noHistory: "–ò—Å—Ç–æ—Ä–∏—è –∏–≥—Ä –Ω–µ –∑–∞–ø–∏—Å–∞–Ω–∞.",
                 helpTitle: "–°–ø—Ä–∞–≤–∫–∞ –∏ –¶–µ–ª—å",
                 helpTextStandard: `<strong>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É –º–æ–∑–≥–∞ –ê–≤–∞–ª–µ!</strong><br><br>–í–∞—à–∞ —Ü–µ–ª—å - <strong>–¥—É–º–∞—Ç—å –∫–∞–∫ —á–µ–º–ø–∏–æ–Ω</strong>, —É–≥–∞–¥—ã–≤–∞—è —Ö–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –æ–Ω —Å–¥–µ–ª–∞–ª –≤ —Ä–µ–∞–ª—å–Ω–æ–π –∏–≥—Ä–µ, –∫–∞–∂–¥—ã–π —Ä–∞–∑, –∫–æ–≥–¥–∞ –Ω–∞—Å—Ç—É–ø–∞–µ—Ç –≤–∞—à–∞ –æ—á–µ—Ä–µ–¥—å (–ò–≥—Ä–æ–∫ üòä ‚Üì).<br><br><strong>–ö–∞–∫ –∏–≥—Ä–∞—Ç—å:</strong><br>1. –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –∏ –æ–¥–Ω—É –∏–∑ –ø–µ—Ä–≤—ã—Ö 3 –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∏–≥—Ä.<br>2. –ö–æ–≥–¥–∞ –Ω–∞—Å—Ç—É–ø–∞–µ—Ç –≤–∞—à–∞ –æ—á–µ—Ä–µ–¥—å (üòä ‚Üì), –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ –¥–æ—Å–∫—É.<br>3. –ù–∞–∂–º–∏—Ç–µ –Ω–∞ –æ–¥–Ω—É –∏–∑ –≤–∞—à–∏—Ö –ª—É–Ω–æ–∫ (A-F), —Å–æ–¥–µ—Ä–∂–∞—â—É—é —Å–µ–º–µ–Ω–∞, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å –µ–µ.<br>4. –í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–æ—Ü–µ–Ω—Ç –≤–∞—à–µ–≥–æ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –±–∞–Ω–∫–∞ –¥–ª—è —Å—Ç–∞–≤–∫–∏ –Ω–∞ —ç—Ç–æ—Ç –≤—ã–±–æ—Ä.<br>5. –ù–∞–∂–º–∏—Ç–µ '–°–¥–µ–ª–∞—Ç—å —Å—Ç–∞–≤–∫—É!'. –ï—Å–ª–∏ –≤–∞—à –≤—ã–±–æ—Ä –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π, –≤—ã –≤—ã–∏–≥—Ä—ã–≤–∞–µ—Ç–µ —Å—Ç–∞–≤–∫—É. –ò–Ω–∞—á–µ - –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–µ—Ç–µ.<br>6. –ö–æ–≥–¥–∞ –Ω–∞—Å—Ç—É–ø–∞–µ—Ç –æ—á–µ—Ä–µ–¥—å –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (üòî ‚Üë), –Ω–∞–∂–º–∏—Ç–µ '–°–ª–µ–¥—É—é—â–∏–π'.<br><br><strong>–ü–µ—Ä–µ–π–¥–∏—Ç–µ –Ω–∞ –ü—Ä–µ–º–∏—É–º!</strong><br>–î–ª—è –ø–æ–ª–Ω–æ–≥–æ –æ–ø—ã—Ç–∞ –∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –Ω–∞—à–µ–π –∞—Å—Å–æ—Ü–∏–∞—Ü–∏–∏, –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Ç–µ—Å—å –∫ <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer">Jeux Nomades France</a>. –ü—Ä–µ–º–∏—É–º –≤–µ—Ä—Å–∏—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä—É–µ—Ç —Å–ª–µ–¥—É—é—â–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏:<ul><li>–î–æ—Å—Ç—É–ø –∫–æ <strong>–≤—Å–µ–º —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–º –∏–≥—Ä–∞–º</strong>.</li><li>–ö–Ω–æ–ø–∫–∏ <strong>"–ò—Å—Ç"</strong> (–∏—Å—Ç–æ—Ä–∏—è) –∏ <strong>"–ó–∞–ø"</strong> (–∑–∞–ø–∏—Å—å –∑–∞–º–µ—Ç–æ–∫).</li><li>–ê–∫—Ç–∏–≤–∞—Ü–∏—è <strong>–≤–∏–∑—É–∞–ª—å–Ω–æ–π –ø–æ–º–æ—â–∏</strong> (–∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –∑–∞—Ö–≤–∞—Ç–∞/–¥–∞–≤–ª–µ–Ω–∏—è).</li><li>–ê–∫—Ç–∏–≤–∞—Ü–∏—è <strong>–∫—Ä–∞—Å–Ω–æ–≥–æ –∫—Ä–µ—Å—Ç–∞</strong> –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è.</li><li>–î–æ—Å—Ç—É–ø –∫ <strong>—Å–µ–∫—Ä–µ—Ç–Ω—ã–º –ø–æ–¥—Å–∫–∞–∑–∫–∞–º</strong>.</li></ul>`,
                 helpTextPremium: `<strong>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ü—Ä–µ–º–∏—É–º –≤–µ—Ä—Å–∏—é!</strong><br><br>–£ –≤–∞—Å –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º —Ñ—É–Ω–∫—Ü–∏—è–º, —á—Ç–æ–±—ã —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞—Ç—å—Å—è –¥—É–º–∞—Ç—å –∫–∞–∫ —á–µ–º–ø–∏–æ–Ω.<br><br><strong>–ü—Ä–µ–º–∏—É–º –§—É–Ω–∫—Ü–∏–∏:</strong><br><ul><li><strong>–í—Å–µ –ò–≥—Ä—ã:</strong> –î–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –∏–≥—Ä–∞–º —á–µ—Ä–µ–∑ —Å–µ–ª–µ–∫—Ç–æ—Ä.</li><li><strong>–ò—Å—Ç–æ—Ä–∏—è ("–ò—Å—Ç"):</strong> –ü—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞–π—Ç–µ —Å–≤–æ–∏ –ø—Ä–æ—à–ª—ã–µ –∏–≥—Ä—ã, —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏.</li><li><strong>–ö–æ—É—á–∏–Ω–≥ –ò–ò —á–µ—Ä–µ–∑ –≠–∫—Å–ø–æ—Ä—Ç JSON:</strong> –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å (JSON)" –≤ –∏—Å—Ç–æ—Ä–∏–∏. –í—Å—Ç–∞–≤—å—Ç–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –≤ —Ä–∞–∑–≥–æ–≤–æ—Ä–Ω—ã–π –ò–ò (–Ω–∞–ø—Ä–∏–º–µ—Ä, ChatGPT, Gemini, Mistral –∏ —Ç.–¥.). –í–∫–ª—é—á–µ–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç –ø–æ–ø—Ä–æ—Å–∏—Ç –ò–ò –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤–∞—à–∏ –∏–≥—Ä—ã (–æ—à–∏–±–∫–∏, –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏) –∏ –¥–∞—Ç—å –≤–∞–º –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ —Å–æ–≤–µ—Ç—ã –ø–æ –∫–æ—É—á–∏–Ω–≥—É, –ø—Ä—è–º–æ –Ω–∞ —è–∑—ã–∫–µ, –≤—ã–±—Ä–∞–Ω–Ω–æ–º –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏!</li><li><strong>–ó–∞–ø–∏—Å—å ("–ó–∞–ø"):</strong> –î–æ–±–∞–≤–ª—è–π—Ç–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–µ –∑–∞–º–µ—Ç–∫–∏ –∫ –∫–∞–∂–¥–æ–º—É —Å–¥–µ–ª–∞–Ω–Ω–æ–º—É —Ö–æ–¥—É.</li><li><strong>–í–∏–∑—É–∞–ª—å–Ω–∞—è –ü–æ–º–æ—â—å:</strong><ul><li>–í–∫–ª—é—á–µ–Ω–∏–µ/–í—ã–∫–ª—é—á–µ–Ω–∏–µ: –î–æ–ª–≥–æ–µ –Ω–∞–∂–∞—Ç–∏–µ (3—Å) –Ω–∞ –∫–Ω–æ–ø–∫—É <strong>+</strong> –≤ –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É.</li><li>–ú–∏–≥–∞—é—â–∞—è –æ—Ä–∞–Ω–∂–µ–≤–∞—è –ª—É–Ω–∫–∞ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞: –í–∞—à –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ö–æ–¥ –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–ø—Ä—è–º—É—é.</li><li>–õ—É–Ω–∫–∞ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ —Å –æ—Ä–∞–Ω–∂–µ–≤–æ–π —Ä–∞–º–∫–æ–π: –î–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ –±—É–¥—É—â–µ–≥–æ –∑–∞—Ö–≤–∞—Ç–∞.</li><li>–í–∞—à–∞ –ª—É–Ω–∫–∞ —Å –ø—É–Ω–∫—Ç–∏—Ä–Ω–æ–π –æ—Ä–∞–Ω–∂–µ–≤–æ–π —Ä–∞–º–∫–æ–π: –£–≥—Ä–æ–∑–∞ –∑–∞—Ö–≤–∞—Ç–∞ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–æ–º.</li></ul></li><li><strong>–ö—Ä–∞—Å–Ω—ã–π –ö—Ä–µ—Å—Ç:</strong><ul><li>–í–∫–ª—é—á–µ–Ω–∏–µ/–í—ã–∫–ª—é—á–µ–Ω–∏–µ: –û–¥–∏–Ω–æ—á–Ω—ã–π –∫–ª–∏–∫ –ø–æ –∫–Ω–æ–ø–∫–µ <strong>+</strong> –≤ –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É.</li><li>–ü–æ–º–æ–≥–∞–µ—Ç –≤–∏–∑—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ –ª—É–Ω–æ–∫.</li></ul></li></ul><strong>–ê–∫—Ç–∏–≤–∏—Ä—É–µ–º—ã–µ –°–µ–∫—Ä–µ—Ç–Ω—ã–µ –ü–æ–¥—Å–∫–∞–∑–∫–∏:</strong><br><ul><li><strong>–õ–æ–≥–æ—Ç–∏–ø x3 –∫–ª–∏–∫–∞:</strong> –°–±—Ä–∞—Å—ã–≤–∞–µ—Ç —Ç–µ–∫—É—â—É—é –∏–≥—Ä—É.</li><li><strong>–ë–∞–Ω–∫ x3 –∫–ª–∏–∫–∞:</strong> –í–∫–ª—é—á–∞–µ—Ç/–í—ã–∫–ª—é—á–∞–µ—Ç —Ä–µ–∂–∏–º "–ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –£—Å–ø–µ—Ö" (–≤—Å–µ —Å—Ç–∞–≤–∫–∏ –≤—ã–∏–≥—Ä—ã–≤–∞—é—Ç).</li><li><strong>–¢–µ–∫—Å—Ç "–°—Ç–∞–≤–∫–∞" x3 –∫–ª–∏–∫–∞:</strong> –ë–ª–æ–∫–∏—Ä—É–µ—Ç/–†–∞–∑–±–ª–æ–∫–∏—Ä—É–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø—Ä–æ—Ü–µ–Ω—Ç —Å—Ç–∞–≤–∫–∏.</li><li><strong>–õ—É–Ω–∫–∞ 'a' –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–Ω–∞–∂–∞—Ç–∏–µ 2—Å):</strong> –û—Ç–º–µ–Ω—è–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å–¥–µ–ª–∞–Ω–Ω—ã–π —Ö–æ–¥.</li><li><strong>–õ—É–Ω–∫–∏ 'f' + 'a' –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–Ω–∞–∂–∞—Ç–∏–µ 3—Å –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ):</strong> –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å–µ–∫—Ä–µ—Ç–Ω—ã—Ö –ø–æ–¥—Å–∫–∞–∑–æ–∫.</li></ul>`,
                 secretMessage: "–ü—Ä–∏–≤–µ—Ç, –≠—Ä–∏–∫",
                 secretTipsTitle: "–°–µ–∫—Ä–µ—Ç–Ω—ã–µ –ü–æ–¥—Å–∫–∞–∑–∫–∏ (–ü—Ä–µ–º–∏—É–º)",
 revealNextMoveMessage: (move) => `–°–ª–µ–¥—É—é—â–∏–π —Ö–æ–¥: ${move}`,
                 secretTips: [ "–õ–æ–≥–æ—Ç–∏–ø x3 –∫–ª–∏–∫–∞: –°–±—Ä–æ—Å –∏–≥—Ä—ã", "–ë–∞–Ω–∫ x3 –∫–ª–∏–∫–∞: –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –£—Å–ø–µ—Ö –í–ö–õ/–í–´–ö–õ", "'–°—Ç–∞–≤–∫–∞' x3 –∫–ª–∏–∫–∞: –ë–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å/–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —Å—Ç–∞–≤–∫—É (%)", "–õ—É–Ω–∫–∞ 'f' –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–Ω–∞–∂–∞—Ç–∏–µ 2—Å): –ü—Ä–∏–≤–µ—Ç, –≠—Ä–∏–∫", "–õ—É–Ω–∫–∞ 'a' –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–Ω–∞–∂–∞—Ç–∏–µ 2—Å): –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ª–µ–¥—É—é—â–∏–π —Ö–æ–¥", "–õ—É–Ω–∫–∏ 'f' + 'a' –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–Ω–∞–∂–∞—Ç–∏–µ 3—Å –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ): –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ—Ç —Å–ø–∏—Å–æ–∫" ],
                 commentModalTitle: "–î–æ–±–∞–≤–∏—Ç—å –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π",
                 commentInputPlaceholder: "–í–∞—à–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∞—è –∑–∞–º–µ—Ç–∫–∞ –∑–¥–µ—Å—å...",
                 // START: Added translations for new comment options (ru)
                 commentOptNoSeedsBC: "–ù–µ—Ç —Å–µ–º—è–Ω –≤ –ª—É–Ω–∫–∞—Ö B –∏ C",
                 commentOptOffensiveOverDefensive: "–ë—ã—Ç—å –ù–∞—Å—Ç—É–ø–∞—Ç–µ–ª—å–Ω—ã–º (–∑–∞—Ö–≤–∞—Ç) > –û–±–æ—Ä–æ–Ω–∏—Ç–µ–ª—å–Ω—ã–º (—É—Ö–æ–¥)",
                 commentOptBuildKrouOffensive: "–°—Ç—Ä–æ–∏—Ç—å –ù–∞—Å—Ç—É–ø–∞—Ç–µ–ª—å–Ω—ã–π –ö—Ä—É (D/E/F) > –û–±–æ—Ä–æ–Ω–∏—Ç–µ–ª—å–Ω—ã–π",
                 commentOptBuildKrouDefensive: "–°—Ç—Ä–æ–∏—Ç—å –û–±–æ—Ä–æ–Ω–∏—Ç–µ–ª—å–Ω—ã–π –ö—Ä—É (C/D/E) > –ù–∞—Å—Ç—É–ø–∞—Ç–µ–ª—å–Ω—ã–π",
                 commentOptBlockOpponentKrou: "–ë–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ö–æ–Ω—Ç—Ä-–ö—Ä—É –ü—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞",
                 commentOptBuildTwoKrous: "–°—Ç—Ä–æ–∏—Ç—å 2 –ö—Ä—É –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ",
                 commentOptMultiCaptureLimit3: "–ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –∑–∞—Ö–≤–∞—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω 3 –ª—É–Ω–∫–∞–º–∏",
                 commentOptMultiCaptureMax5: "–ú–∞–∫—Å. –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –∑–∞—Ö–≤–∞—Ç (5 –ª—É–Ω–æ–∫)",
                 commentOptSpeedUpGame: "–£—Å–∫–æ—Ä–∏—Ç—å –∏–≥—Ä—É",
                 commentOptSlowDownGame: "–ó–∞–º–µ–¥–ª–∏—Ç—å –∏–≥—Ä—É",
                 commentOptCaseToStudy: "–°–ª—É—á–∞–π –¥–ª—è –∏–∑—É—á–µ–Ω–∏—è",
                 // END: Added translations for new comment options (ru)
                 historyTitle: "–ò—Å—Ç–æ—Ä–∏—è –ò–≥—Ä",
                 historyRecordTitle: (name, date) => `–ò–≥—Ä–∞: ${name} (${date})`,
                 historyStats: (rate, pot, duration) => `–£—Å–ø–µ—Ö: ${rate}% | –§–∏–Ω–∞–ª—å–Ω—ã–π –ë–∞–Ω–∫: ${pot}‚Ç¨ | –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: ${duration}—Å`,
                 historyCommentsTitle: "–ó–∞–ø–∏—Å–∞–Ω–Ω—ã–µ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏",
                 historyErrorsTitle: "–û—à–∏–±–∫–∏ –°—Ç–∞–≤–æ–∫",
                 historyNoComments: "–ù–µ—Ç –∑–∞–ø–∏—Å–∞–Ω–Ω—ã—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –¥–ª—è —ç—Ç–æ–π –∏–≥—Ä—ã.",
                 historyNoErrors: "–ù–µ—Ç –∑–∞–ø–∏—Å–∞–Ω–Ω—ã—Ö –æ—à–∏–±–æ–∫ —Å—Ç–∞–≤–æ–∫ –¥–ª—è —ç—Ç–æ–π –∏–≥—Ä—ã.",
                 historyInProgress: "(–í –ø—Ä–æ—Ü–µ—Å—Å–µ)",
                 historyMoveLabel: "–•–æ–¥",
                 historyBetErrorLabel: (bet, correct, potChange, date) => `–°—Ç–∞–≤–∫–∞ <span class="error-detail">${bet}</span> –ø—Ä–æ—Ç–∏–≤ <span class="error-detail">${correct}</span> (–ë–∞–Ω–∫ ${potChange > 0 ? '+' : ''}${potChange}‚Ç¨) <small>(${date})</small>`,
                 premiumModalTitle: "–ü—Ä–µ–º–∏—É–º –§—É–Ω–∫—Ü–∏—è",
                 premiumModalText: "–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è, –∞ —Ç–∞–∫–∂–µ –¥—Ä—É–≥–∏–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞, –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ –ü—Ä–µ–º–∏—É–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.",
                 premiumModalBenefitsTitle: "–ü—Ä–µ–º–∏—É–º –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:",
                 premiumBenefitLevels: "–î–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–º –∏–≥—Ä–∞–º.",
                 premiumBenefitHistory: "–ö–Ω–æ–ø–∫–∞ '–ò—Å—Ç' –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏ –∞–Ω–∞–ª–∏–∑–∞ –≤–∞—à–∏—Ö –ø—Ä–æ—à–ª—ã—Ö –∏–≥—Ä.",
                 premiumBenefitRecord: "–ö–Ω–æ–ø–∫–∞ '–ó–∞–ø' –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤.",
                 premiumBenefitAids: "–ê–∫—Ç–∏–≤–∞—Ü–∏—è –≤–∏–∑—É–∞–ª—å–Ω–æ–π –ø–æ–º–æ—â–∏ (–∑–∞—Ö–≤–∞—Ç—ã/–¥–∞–≤–ª–µ–Ω–∏–µ).",
                 premiumBenefitCross: "–ê–∫—Ç–∏–≤–∞—Ü–∏—è –∫—Ä–∞—Å–Ω–æ–≥–æ –∫—Ä–µ—Å—Ç–∞ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è.",
                 premiumBenefitSecrets: "–î–æ—Å—Ç—É–ø –∫ —Å–µ–∫—Ä–µ—Ç–Ω—ã–º –ø–æ–¥—Å–∫–∞–∑–∫–∞–º.",
                 premiumModalHowto: "–ß—Ç–æ–±—ã —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ü—Ä–µ–º–∏—É–º –≤–µ—Ä—Å–∏—é –∏ –ø–æ–¥–¥–µ—Ä–∂–∞—Ç—å –Ω–∞—à—É –∞—Å—Å–æ—Ü–∏–∞—Ü–∏—é, —Å—Ç–∞–Ω—å—Ç–µ —á–ª–µ–Ω–æ–º <strong>Jeux Nomades France</strong>:",
                 premiumModalActionLink: "–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –∞—Å—Å–æ—Ü–∏–∞—Ü–∏–∏",
                 gameDropdownFormat: (index, moves) => `–ò–≥—Ä–∞ ${index} (${moves} —Ö–æ–¥–æ–≤)`,
                 encouragingMessages: [ "–ë—Ä–∞–≤–æ!", "–û—Ç–ª–∏—á–Ω–æ!", "–ü—Ä–µ–≤–æ—Å—Ö–æ–¥–Ω–æ!", "–¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å!", "–í–ø–µ—á–∞—Ç–ª—è—é—â–µ!", "–í–µ–ª–∏–∫–æ–ª–µ–ø–Ω–æ!", "–£–º–µ–ª–æ!", "–ó–∞–º–µ—á–∞—Ç–µ–ª—å–Ω–æ!", "–ù–µ–≤–µ—Ä–æ—è—Ç–Ω–æ!", "–ü–æ—Ç—Ä—è—Å–∞—é—â–µ!", "–ò–¥–µ–∞–ª—å–Ω–æ!", "–ó–∞—Ö–≤–∞—Ç—ã–≤–∞—é—â–µ!", "–í–æ—Å—Ö–æ–¥—è—â–∞—è –∑–≤–µ–∑–¥–∞!", "–°–µ–Ω—Å–∞—Ü–∏–æ–Ω–Ω–æ!", "–¢—Ä–∏—É–º—Ñ!", "–ú–∞—Å—Ç–µ—Ä!", "–õ–µ–≥–µ–Ω–¥–∞—Ä–Ω–æ!", "–ì–µ–Ω–∏–π!", "–ß–µ–º–ø–∏–æ–Ω!", "–ë–µ—Å—Å–º–µ—Ä—Ç–Ω—ã–π!" ]
             },
             zh: {
                 pageTitle: "ÂÜ†ÂÜõÊÄùÁª¥",
                 languageLabel: "ËØ≠Ë®Ä:",
                 levelLabel: "Ê£ãÂ±Ä:",
                 title: "ÂÜ†ÂÜõÊÄùÁª¥!",
                 moveInfo: (p1, p2) => `Áé©ÂÆ∂ üòä ‚Üì: ${p1} | Áé©ÂÆ∂ üòî ‚Üë: ${p2}`,
                 betPotInfo: (pot) => `ÂΩ©Ê±†:<BR>${pot} ‚Ç¨`,
                 successRate: (rate) => `ÊàêÂäüÁéá:<BR>${rate} %`,
                 playedMoves: (index, total, moves) => `${index} / ${total} | ÊúÄËøëÂá†Ê≠•: ${moves}`,
                 betLabel: "Êàë‰∏ãÊ≥®",
                 betCaseLabel: "Âú®",
                 betButton: "‰∏ãÊ≥®!",
                 nextButton: "‰∏ã‰∏ÄÊ≠•",
                 recordButtonShort: "ËÆ∞ÂΩï",
                 historyButtonShort: "ÂéÜÂè≤",
                 closeButton: "ÂÖ≥Èó≠",
                 saveButton: "‰øùÂ≠ò",
                 cancelButton: "ÂèñÊ∂à",
                 copyButton: "Â§çÂà∂ (JSON)",
                 resetButton: "ÈáçÁΩÆ",
                 tooltipPot: "ÊÇ®ÂΩìÂâçÁöÑËôöÊãüËµÑÈáë",
                 tooltipSuccessRate: "Ê≠§Â±ÄÊ∏∏Êàè‰∏≠Ê≠£Á°Æ‰∏ãÊ≥®ÁöÑÁôæÂàÜÊØî",
                 tooltipRecord: "‰∏∫Ê≠§Ê≠•ËÆ∞ÂΩïËØÑËÆ∫ (È´òÁ∫ßÁâà)",
                 tooltipHistory: "Êü•ÁúãÂ∑≤Áé©ËøáÁöÑÊ£ãÂ±ÄÂéÜÂè≤ (È´òÁ∫ßÁâà)",
                 tooltipHelp: "ÊòæÁ§∫Â∏ÆÂä©/ËßÑÂàô",
                 tooltipTheme: "Ê∑±Ëâ≤/ÊµÖËâ≤Ê®°Âºè",
                 tooltipCross: "È´òÁ∫ßÈÄâÈ°π (ÂçÅÂ≠óÁ∫ø / ËæÖÂä©)",
                 resultInvalidBet: "Êó†Êïà‰∏ãÊ≥®!",
                 resultWin: "Ëµ¢‰∫Ü!",
                 resultLose: "Ëæì‰∫Ü!",
                 resultGameOver: "Ê£ãÂ±ÄÁªìÊùü!",
                 resetMessage: "Ê£ãÂ±ÄÂ∑≤ÈáçÁΩÆ!",
                 premiumUnlockedMessage: "È´òÁ∫ßÁâàÂ∑≤ÊøÄÊ¥ª! ÂäüËÉΩÂ∑≤Ëß£ÈîÅ„ÄÇ",
                 successOnMessage: "‰øùËØÅÊàêÂäü ÂºÄÂêØ",
                 successOffMessage: "‰øùËØÅÊàêÂäü ÂÖ≥Èó≠",
                 betLockedMessage: (pct) => `‰∏ãÊ≥®Â∑≤ÈîÅÂÆö (${pct}%)`,
                 betUnlockedMessage: "‰∏ãÊ≥®Â∑≤Ëß£ÈîÅ",
                 backMessage: "Êí§ÈîÄÊàêÂäü",
                 opponentTurnMessage: "ÁÇπÂáª‰∏ã‰∏ÄÊ≠• (ÂØπÊâãÂõûÂêà)",
                 playerTurnIndicator: "ËΩÆÂà∞ÊÇ®: ÈÄâÊã©Âπ∂‰∏ãÊ≥®!",
                 opponentTurnIndicator: "ÂØπÊâãÂõûÂêà (ÁÇπÂáª‰∏ã‰∏ÄÊ≠•)",
                 emptyHoleMessage: "Á©∫Á©¥!",
                 notYourTurnMessage: "ËøòÊ≤°ËΩÆÂà∞ÊÇ®! ÁÇπÂáª '‰∏ã‰∏ÄÊ≠•'.",
                 invalidHoleMessage: "Êó†ÊïàÊàñÁ©∫Á©¥!",
                 internalErrorMessage: "ÂÜÖÈÉ®Ê®°ÊãüÈîôËØØ„ÄÇ",
                 aidesEnabled: "ËßÜËßâËæÖÂä©Â∑≤ÂêØÁî®",
                 aidesDisabled: "ËßÜËßâËæÖÂä©Â∑≤Á¶ÅÁî®",
                 crossEnabled: "Á∫¢ÂçÅÂ≠óÁ∫øÂ∑≤ÂêØÁî®",
                 crossDisabled: "Á∫¢ÂçÅÂ≠óÁ∫øÂ∑≤Á¶ÅÁî®",
                 highlightDisabledMsg: "È´ò‰∫ÆÂ∑≤Á¶ÅÁî®Ôºà‰∏≠ÊÄßÊà™ÂõæÔºâ",
                 highlightEnabledMsg: "È´ò‰∫ÆÂ∑≤ÂêØÁî®",
                 errorDisplayMessage: "ÊòæÁ§∫ÈîôËØØ„ÄÇËØ∑ÈáçÊñ∞Âä†ËΩΩ„ÄÇ",
                 confirmResetHistory: "ÊÇ®Á°ÆÂÆöË¶ÅÈáçÁΩÆÂÖ®ÈÉ®ÂéÜÂè≤ËÆ∞ÂΩïÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÈÄÜ„ÄÇ",
                 historyResetSuccess: "ÂéÜÂè≤ËÆ∞ÂΩïÂ∑≤ÈáçÁΩÆ!",
                 copySuccess: "ÂéÜÂè≤ËÆ∞ÂΩïÂÜÖÂÆπÂ∑≤Â§çÂà∂!",
                 copyError: "Â§çÂà∂Êó∂Âá∫Èîô„ÄÇ",
                 copyPrepareError: "ÂáÜÂ§áÂ§çÂà∂Êó∂Âá∫Èîô„ÄÇ",
                 noHistory: "Ê≤°ÊúâËÆ∞ÂΩïÁöÑÊ£ãÂ±ÄÂéÜÂè≤„ÄÇ",
                 helpTitle: "Â∏ÆÂä©‰∏éÁõÆÊ†á",
                 helpTextStandard: `<strong>Ê¨¢ËøéÊù•Âà∞ Awal√© Â§ßËÑëËÆ≠ÁªÉ!</strong><br><br>ÊÇ®ÁöÑÁõÆÊ†áÊòØ<strong>ÂÉèÂÜ†ÂÜõ‰∏ÄÊ†∑ÊÄùËÄÉ</strong>ÔºåÂú®ÊØèÊ¨°ËΩÆÂà∞ÊÇ®Êó∂ (Áé©ÂÆ∂ üòä ‚Üì) ÁåúÊµã‰ªñ‰ª¨Âú®ÁúüÂÆûÊ£ãÂ±Ä‰∏≠Ëµ∞Âá∫ÁöÑÈÇ£‰∏ÄÊ≠•„ÄÇ<br><br><strong>Áé©Ê≥ïËØ¥Êòé:</strong><br>1. ÈÄâÊã©‰∏ÄÁßçËØ≠Ë®ÄÂíåÂâç3‰∏™ÂèØÁî®Ê£ãÂ±Ä‰πã‰∏Ä„ÄÇ<br>2. ËΩÆÂà∞ÊÇ®Êó∂ (üòä ‚Üì)ÔºåËßÇÂØüÊ£ãÁõò„ÄÇ<br>3. ÁÇπÂáªÊÇ®ÂÖ∂‰∏≠‰∏Ä‰∏™ÂåÖÂê´Ê£ãÂ≠ê (ÁßçÂ≠ê) ÁöÑÊ£ãÁ©¥ (A-F) Êù•ÈÄâÊã©ÂÆÉ„ÄÇ<br>4. ÈÄâÊã©ÊÇ®ËôöÊãüÂΩ©Ê±†ÁöÑ‰∏Ä‰∏™ÁôæÂàÜÊØîÔºåÂØπÊ≠§ÈÄâÊã©‰∏ãÊ≥®„ÄÇ<br>5. ÁÇπÂáª '‰∏ãÊ≥®!'„ÄÇÂ¶ÇÊûúÊÇ®ÁöÑÈÄâÊã©Ê≠£Á°ÆÔºåÊÇ®Ëµ¢ÂæóËµåÊ≥®„ÄÇÂê¶ÂàôÔºåÊÇ®ËæìÊéâËµåÊ≥®„ÄÇ<br>6. ËΩÆÂà∞ÂØπÊâãÊó∂ (üòî ‚Üë)ÔºåÁÇπÂáª '‰∏ã‰∏ÄÊ≠•'„ÄÇ<br><br><strong>ÂçáÁ∫ßÂà∞È´òÁ∫ßÁâà!</strong><br>‰∏∫‰∫ÜËé∑ÂæóÂÆåÊï¥‰ΩìÈ™åÂπ∂ÊîØÊåÅÊàë‰ª¨ÁöÑÂçè‰ºöÔºåËØ∑Âä†ÂÖ• <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer">Jeux Nomades France</a>„ÄÇÈ´òÁ∫ßÁâàËß£ÈîÅ‰ª•‰∏ãÂäüËÉΩÔºö<ul><li>ËÆøÈóÆ<strong>ÊâÄÊúâËÆ≠ÁªÉÊ£ãÂ±Ä</strong>„ÄÇ</li><li><strong>"ÂéÜÂè≤"</strong> (ÂéÜÂè≤ËÆ∞ÂΩï) Âíå <strong>"ËÆ∞ÂΩï"</strong> (ËÆ∞ÂΩïÁ¨îËÆ∞) ÊåâÈíÆ„ÄÇ</li><li>ÊøÄÊ¥ª<strong>ËßÜËßâËæÖÂä©</strong> (ÊäìÂ≠ê/ÂéãÂäõÊåáÁ§∫)„ÄÇ</li><li>ÊøÄÊ¥ª<strong>Á∫¢Ëâ≤ÂØπÈΩêÂçÅÂ≠óÁ∫ø</strong>„ÄÇ</li><li>ËÆøÈóÆ<strong>ÁßòÂØÜÊèêÁ§∫</strong>„ÄÇ</li></ul>`,
                 helpTextPremium: `<strong>Ê¨¢ËøéÊù•Âà∞È´òÁ∫ßÁâà!</strong><br><br>ÊÇ®ÂèØ‰ª•‰ΩøÁî®ÊâÄÊúâÂäüËÉΩÊù•ËÆ≠ÁªÉËá™Â∑±ÂÉèÂÜ†ÂÜõ‰∏ÄÊ†∑ÊÄùËÄÉ„ÄÇ<br><br><strong>È´òÁ∫ßÁâàÂäüËÉΩ:</strong><br><ul><li><strong>ÊâÄÊúâÊ£ãÂ±Ä:</strong> ÈÄöËøáÈÄâÊã©Âô®ËÆøÈóÆÊâÄÊúâÊ£ãÂ±Ä„ÄÇ</li><li><strong>ÂéÜÂè≤ ("ÂéÜÂè≤"):</strong> Êü•ÁúãÊÇ®ËøáÂéªÁöÑÊ£ãÂ±Ä„ÄÅÁªüËÆ°Êï∞ÊçÆÂíåËØÑËÆ∫„ÄÇ</li><li><strong>ÈÄöËøá JSON ÂØºÂá∫ËøõË°å AI ÊåáÂØº:</strong> ‰ΩøÁî®ÂéÜÂè≤ËÆ∞ÂΩï‰∏≠ÁöÑ "Â§çÂà∂ (JSON)" ÊåâÈíÆ„ÄÇÂ∞ÜÂ§çÂà∂ÁöÑÊñáÊú¨Á≤òË¥¥Âà∞ÂØπËØùÂºè‰∫∫Â∑•Êô∫ËÉΩ (Â¶Ç ChatGPT, Gemini, Mistral Á≠â) ‰∏≠„ÄÇÂåÖÂê´ÁöÑÊèêÁ§∫Â∞ÜË¶ÅÊ±Ç AI ÂàÜÊûêÊÇ®ÁöÑÊ£ãÂ±Ä (ÈîôËØØ„ÄÅËØÑËÆ∫) Âπ∂‰∏∫ÊÇ®Êèê‰æõ‰∏™ÊÄßÂåñÁöÑÊåáÂØºÂª∫ËÆÆÔºåÁõ¥Êé•‰ΩøÁî®Â∫îÁî®Á®ãÂ∫è‰∏≠ÈÄâÊã©ÁöÑËØ≠Ë®ÄÔºÅ</li><li><strong>ËÆ∞ÂΩï ("ËÆ∞ÂΩï"):</strong> ‰∏∫ÊØè‰∏ÄÊ≠•Ê£ãÊ∑ªÂä†ÊàòÁï•Á¨îËÆ∞„ÄÇ</li><li><strong>ËßÜËßâËæÖÂä©:</strong><ul><li>ÊøÄÊ¥ª/ÂÅúÁî®: ÈïøÊåâ (3Áßí) Âè≥‰∏äËßíÁöÑ <strong>+</strong> ÊåâÈíÆ„ÄÇ</li><li>Èó™ÁÉÅÁöÑÊ©ôËâ≤ÂØπÊâãÊ£ãÁ©¥: ÊÇ®ÈÄâÊã©ÁöÑÊ≠•Êï∞Áõ¥Êé•ÊäìÂ≠ê„ÄÇ</li><li>Â∏¶Ê©ôËâ≤ËæπÊ°ÜÁöÑÂØπÊâãÊ£ãÁ©¥: Êú™Êù•ÂèØËÉΩÊäìÂ≠êÁöÑÂéãÂäõ„ÄÇ</li><li>Â∏¶Ê©ôËâ≤ËôöÁ∫øËæπÊ°ÜÁöÑÊÇ®ÁöÑÊ£ãÁ©¥: ÂØπÊâãÊäìÂ≠êÁöÑÂ®ÅËÉÅ„ÄÇ</li></ul></li><li><strong>Á∫¢ÂçÅÂ≠óÁ∫ø:</strong><ul><li>ÊøÄÊ¥ª/ÂÅúÁî®: ÂçïÂáªÂè≥‰∏äËßíÁöÑ <strong>+</strong> ÊåâÈíÆ„ÄÇ</li><li>Â∏ÆÂä©ÂèØËßÜÂåñÊ£ãÁ©¥ÂØπÈΩê„ÄÇ</li></ul></li></ul><strong>ÂèØÊøÄÊ¥ªÁöÑÁßòÂØÜÊèêÁ§∫:</strong><br><ul><li><strong>Logo x3 ÁÇπÂáª:</strong> ÈáçÁΩÆÂΩìÂâçÊ£ãÂ±Ä„ÄÇ</li><li><strong>ÂΩ©Ê±† x3 ÁÇπÂáª:</strong> ÂàáÊç¢ "‰øùËØÅÊàêÂäü" Ê®°Âºè (ÊâÄÊúâ‰∏ãÊ≥®ÈÉΩËµ¢)„ÄÇ</li><li><strong>"Êàë‰∏ãÊ≥®" ÊñáÊú¨ x3 ÁÇπÂáª:</strong> ÈîÅÂÆö/Ëß£ÈîÅÈÄâÂÆöÁöÑ‰∏ãÊ≥®ÁôæÂàÜÊØî„ÄÇ</li><li><strong>ÂØπÊâã 'a' Ê£ãÁ©¥ (ÈïøÊåâ 2Áßí):</strong> ÊòæÁ§∫‰∏ã‰∏ÄÊ≠•</li><li><strong>ÂØπÊâã 'f' + 'a' Ê£ãÁ©¥ (ÂêåÊó∂ÈïøÊåâ 3Áßí):</strong> ÊòæÁ§∫ÁßòÂØÜÊèêÁ§∫ÂàóË°®„ÄÇ</li></ul>`,
                 secretMessage: "‰Ω†Â•Ω",
                 secretTipsTitle: "ÁßòÂØÜÊèêÁ§∫ (È´òÁ∫ßÁâà)",
 revealNextMoveMessage: (move) => `‰∏ã‰∏ÄÊ≠•: ${move}`,
                 secretTips: [ "Logo x3 ÁÇπÂáª: ÈáçÁΩÆÊ£ãÂ±Ä", "ÂΩ©Ê±† x3 ÁÇπÂáª: ‰øùËØÅÊàêÂäü ÂºÄ/ÂÖ≥", "'Êàë‰∏ãÊ≥®' x3 ÁÇπÂáª: ÈîÅÂÆö/Ëß£ÈîÅ ‰∏ãÊ≥® (%)", "ÂØπÊâã 'f' Ê£ãÁ©¥ (ÈïøÊåâ 2Áßí): ‰Ω†Â•Ω", "ÂØπÊâã 'a' Ê£ãÁ©¥ (ÈïøÊåâ 2Áßí): Êí§ÈîÄ‰∏ä‰∏ÄÊ≠•", "ÂØπÊâã 'f' + 'a' Ê£ãÁ©¥ (ÂêåÊó∂ÈïøÊåâ 3Áßí): ÊòæÁ§∫Ê≠§ÂàóË°®" ],
                 commentModalTitle: "Ê∑ªÂä†ËØÑËÆ∫",
                 commentInputPlaceholder: "Âú®Ê≠§Â§ÑËæìÂÖ•ÊÇ®ÁöÑÊàòÁï•Á¨îËÆ∞...",
                 // START: Added translations for new comment options (zh)
                 commentOptNoSeedsBC: "B Âíå C Ê¥û‰∏≠Ê≤°ÊúâÁßçÂ≠ê",
                 commentOptOffensiveOverDefensive: "ÈááÂèñËøõÊîªÔºàÂêÉÂ≠êÔºâ> Èò≤ÂÆàÔºàÈÄÉËÑ±Ôºâ",
                 commentOptBuildKrouOffensive: "Âª∫Á´ãËøõÊîªÊÄß Krou (D/E/F) > Èò≤ÂÆàÊÄß",
                 commentOptBuildKrouDefensive: "Âª∫Á´ãÈò≤ÂÆàÊÄß Krou (C/D/E) > ËøõÊîªÊÄß",
                 commentOptBlockOpponentKrou: "ÈòªÊ≠¢ÂØπÊâãÁöÑÂèç Krou",
                 commentOptBuildTwoKrous: "ÂêåÊó∂Âª∫Á´ã 2 ‰∏™ Krous",
                 commentOptMultiCaptureLimit3: "Â§öÈáçÂêÉÂ≠êÈôêÂà∂‰∏∫ 3 ‰∏™Ê¥û",
                 commentOptMultiCaptureMax5: "ÊúÄÂ§ßÂ§öÈáçÂêÉÂ≠êÔºà5 ‰∏™Ê¥ûÔºâ",
                 commentOptSpeedUpGame: "Âä†Âø´Ê∏∏Êàè",
                 commentOptSlowDownGame: "ÂáèÊÖ¢Ê∏∏Êàè",
                 commentOptCaseToStudy: "ÂæÖÁ†îÁ©∂Ê°à‰æã",
                 // END: Added translations for new comment options (zh)
                 historyTitle: "Ê£ãÂ±ÄÂéÜÂè≤",
                 historyRecordTitle: (name, date) => `Ê£ãÂ±Ä: ${name} (${date})`,
                 historyStats: (rate, pot, duration) => `ÊàêÂäüÁéá: ${rate}% | ÊúÄÁªàÂΩ©Ê±†: ${pot}‚Ç¨ | Êó∂Èïø: ${duration}Áßí`,
                 historyCommentsTitle: "Â∑≤ËÆ∞ÂΩïËØÑËÆ∫",
                 historyErrorsTitle: "‰∏ãÊ≥®ÈîôËØØ",
                 historyNoComments: "Ê≠§Ê£ãÂ±ÄÊ≤°ÊúâËÆ∞ÂΩïÁöÑËØÑËÆ∫„ÄÇ",
                 historyNoErrors: "Ê≠§Ê£ãÂ±ÄÊ≤°ÊúâËÆ∞ÂΩïÁöÑ‰∏ãÊ≥®ÈîôËØØ„ÄÇ",
                 historyInProgress: "(ËøõË°å‰∏≠)",
                 historyMoveLabel: "Ê≠•Êï∞",
                 historyBetErrorLabel: (bet, correct, potChange, date) => `‰∏ãÊ≥® <span class="error-detail">${bet}</span> ÂØπÊØî <span class="error-detail">${correct}</span> (ÂΩ©Ê±† ${potChange > 0 ? '+' : ''}${potChange}‚Ç¨) <small>(${date})</small>`,
                 premiumModalTitle: "È´òÁ∫ßÁâàÂäüËÉΩ",
                 premiumModalText: "Ê≠§ÂäüËÉΩ‰ª•ÂèäÂÖ∂‰ªñÂ•ΩÂ§Ñ‰ªÖÈôêÈ´òÁ∫ß‰ºöÂëò‰ΩøÁî®„ÄÇ",
                 premiumModalBenefitsTitle: "È´òÁ∫ßÁâàÂ•ΩÂ§Ñ:",
                 premiumBenefitLevels: "ËÆøÈóÆÊâÄÊúâËÆ≠ÁªÉÊ£ãÂ±Ä„ÄÇ",
                 premiumBenefitHistory: "‚ÄúÂéÜÂè≤‚ÄùÊåâÈíÆÂèØÊü•ÁúãÂíåÂàÜÊûêÊÇ®ËøáÂéªÁöÑÊ£ãÂ±Ä„ÄÇ",
                 premiumBenefitRecord: "‚ÄúËÆ∞ÂΩï‚ÄùÊåâÈíÆÂèØÊ∑ªÂä†ÊàòÁï•ËØÑËÆ∫„ÄÇ",
                 premiumBenefitAids: "ÊøÄÊ¥ªËßÜËßâËæÖÂä©ÔºàÂêÉÂ≠ê/ÂéãÂäõÔºâ„ÄÇ",
                 premiumBenefitCross: "ÊøÄÊ¥ªÁ∫¢Ëâ≤ÂØπÈΩêÂçÅÂ≠óÁ∫ø„ÄÇ",
                 premiumBenefitSecrets: "ËÆøÈóÆÁßòÂØÜÊèêÁ§∫„ÄÇ",
                 premiumModalHowto: "Ë¶ÅËß£ÈîÅÈ´òÁ∫ßÁâàÂπ∂ÊîØÊåÅÊàë‰ª¨ÁöÑÂçè‰ºöÔºåËØ∑Êàê‰∏∫ <strong>Jeux Nomades France</strong> ÁöÑ‰ºöÂëòÔºö",
                 premiumModalActionLink: "Âä†ÂÖ•Âçè‰ºö",
                 gameDropdownFormat: (index, moves) => `Ê£ãÂ±Ä ${index} (${moves} Ê≠•)`,
                 encouragingMessages: [ "Â§™Ê£í‰∫Ü!", "Â•ΩÊ†∑ÁöÑ!", "ÈùûÂ∏∏Âá∫Ëâ≤!", "ÁªßÁª≠Âä™Âäõ!", "‰ª§‰∫∫Âç∞Ë±°Ê∑±Âàª!", "Â§™Á≤æÂΩ©‰∫Ü!", "ÊäÄÊúØÂ®¥ÁÜü!", "Â§™Â•Ω‰∫Ü!", "‰∏çÂèØÊÄùËÆÆ!", "ÁúüÊ£í!", "ÂÆåÁæé!", "ÊÉäËâ≥!", "ÂêéËµ∑‰πãÁßÄ!", "ËΩ∞Âä®!", "ËÉúÂà©!", "Â§ßÂ∏à!", "‰º†Â•á!", "Â§©Êâç!", "ÂÜ†ÂÜõ!", "‰∏çÊúΩ!" ]
             }
        };
        // --- Fonctions Utilitaires ---
        function closeModal(modalId) {
             const modal = document.getElementById(modalId);
             if (modal) modal.style.display = 'none';
        }
        function showPremiumInfoModal() {
             const t = translations[currentLanguage] || translations.en;
             document.getElementById('premium-modal-title').textContent = t.premiumModalTitle;
             document.getElementById('premium-modal-text').textContent = t.premiumModalText;
             document.getElementById('premium-modal-benefits-title').textContent = t.premiumModalBenefitsTitle;
             document.getElementById('premium-benefit-levels').textContent = t.premiumBenefitLevels;
             document.getElementById('premium-benefit-history').textContent = t.premiumBenefitHistory;
             document.getElementById('premium-benefit-record').textContent = t.premiumBenefitRecord;
             document.getElementById('premium-benefit-aids').textContent = t.premiumBenefitAids;
             document.getElementById('premium-benefit-cross').textContent = t.premiumBenefitCross;
             document.getElementById('premium-benefit-secrets').textContent = t.premiumBenefitSecrets;
             document.getElementById('premium-modal-howto').innerHTML = t.premiumModalHowto;
             document.getElementById('premium-modal-action-link').textContent = t.premiumModalActionLink;
             document.getElementById('premium-modal-close').textContent = t.closeButton;
             const modal = document.getElementById('premium-info-modal');
             if (modal) modal.style.display = 'block';
        }
        function toggleCrossVisibility() {
             const t = translations[currentLanguage] || translations.en;
             if (!isPremium) { showPremiumInfoModal(); return; }
             isCrossVisible = !isCrossVisible;
             applyCrossVisibility();
             // showTemporaryMessage(isCrossVisible ? t.crossEnabled : t.crossDisabled); // Optional message
        }
        function applyCrossVisibility() {
            const crossElement = document.getElementById('red-cross');
            if (crossElement) { crossElement.style.display = (isPremium && isCrossVisible) ? 'flex' : 'none'; }
        }
        function toggleAides() {
             const t = translations[currentLanguage] || translations.en;
             if (!isPremium) { showPremiumInfoModal(); return; }
             areAidesEnabled = !areAidesEnabled;
             showTemporaryMessage(areAidesEnabled ? t.aidesEnabled : t.aidesDisabled);
             renderBoard();
        }
        function toggleHighlightForScreenshot() {
            const t = translations[currentLanguage] || translations.en;
            if (!isPremium) { showPremiumInfoModal(); return; }
            highlightDisabled = !highlightDisabled;
            showTemporaryMessage(highlightDisabled ? t.highlightDisabledMsg : t.highlightEnabledMsg);
            renderBoard();
        }
        function showTemporaryMessage(message) {
             const resultEl = document.getElementById('result');
             if (resultEl) {
                 const originalText = resultEl.textContent;
                 const originalColor = resultEl.style.color;
                 resultEl.textContent = message;
                 resultEl.style.color = '#17a2b8'; // Info color
                 setTimeout(() => {
                     if (resultEl.textContent === message) {
                         resultEl.textContent = originalText;
                         resultEl.style.color = originalColor;
                     }
                 }, 2000);
             }
        }
        function loadGameRecords() {
            const savedRecords = localStorage.getItem('awaleGameRecords');
            if (savedRecords) {
                try {
                     gameRecords = JSON.parse(savedRecords);
                     if (!Array.isArray(gameRecords)) gameRecords = [];
                } catch (e) { console.error("Error parsing saved records:", e); gameRecords = []; }
            } else { gameRecords = []; }
        }
        function saveGameRecords() {
            try { localStorage.setItem('awaleGameRecords', JSON.stringify(gameRecords)); }
            catch (e) { console.error("Error saving game records:", e); }
        }
        // --- Fonction de Mise √† Jour Langue (MODIFI√âE pour inclure les nouvelles options de commentaire) ---
        function updateLanguage() {
            currentLanguage = document.getElementById("language-select").value || "fr";
            const t = translations[currentLanguage] || translations.en;
            console.log("Updating language to:", currentLanguage);
            document.documentElement.lang = currentLanguage;
            document.title = t.pageTitle;
            try {
                // Static Labels & Buttons
                document.getElementById("language-label").textContent = t.languageLabel;
                document.getElementById("level-label").textContent = t.levelLabel;
                document.getElementById("title").textContent = t.title;
                document.getElementById("bet-label").textContent = t.betLabel;
                document.getElementById("bet-case-label").textContent = t.betCaseLabel;
                document.getElementById("bet-and-verify-btn").textContent = t.betButton;
                document.getElementById("next-btn").textContent = t.nextButton;
                const recordBtn = document.getElementById('record-btn');
                if (recordBtn) { recordBtn.textContent = t.recordButtonShort; recordBtn.title = t.tooltipRecord; }
                const historyBtn = document.getElementById('history-btn');
                if (historyBtn) { historyBtn.textContent = t.historyButtonShort; historyBtn.title = t.tooltipHistory; }
                document.getElementById("help-btn").title = t.tooltipHelp;
                document.getElementById("theme-toggle").title = t.tooltipTheme;
                document.getElementById("cross-toggle-btn").title = t.tooltipCross;
                const betPotInfoEl = document.getElementById('bet-pot-info');
                if (betPotInfoEl) betPotInfoEl.title = t.tooltipPot;
                const successRateEl = document.getElementById('success-rate');
                if (successRateEl) successRateEl.title = t.tooltipSuccessRate;
                // Modal Content Updates
                // Help Modal
                document.getElementById("help-title").textContent = t.helpTitle;
                const helpTextElement = document.getElementById("help-text");
                if (helpTextElement) {
                    const helpTextContent = isPremium ? (t.helpTextPremium || t.helpTextStandard) : t.helpTextStandard;
                    helpTextElement.innerHTML = helpTextContent;
                }
                 const helpCloseBtn = document.getElementById('help-modal-close');
                 if(helpCloseBtn) helpCloseBtn.textContent = t.closeButton;
                // Secret Tips Modal
                 document.getElementById("secret-tips-title").textContent = t.secretTipsTitle;
                 const tipsList = document.getElementById('secret-tips');
                 if(tipsList) tipsList.innerHTML = (t.secretTips || []).map(tip => `<li>${tip}</li>`).join('');
                 const secretCloseBtn = document.getElementById('secret-modal-close');
                 if(secretCloseBtn) secretCloseBtn.textContent = t.closeButton;
                // History Modal Buttons
                 document.getElementById("history-title").textContent = t.historyTitle;
                 const historyCopyBtn = document.getElementById('history-copy-btn');
                 if(historyCopyBtn) historyCopyBtn.textContent = t.copyButton;
                 const historyResetBtn = document.getElementById('history-reset-btn');
                 if(historyResetBtn) historyResetBtn.textContent = t.resetButton;
                 const historyCloseBtn = document.getElementById('history-close-btn');
                 if(historyCloseBtn) historyCloseBtn.textContent = t.closeButton;
                 // Comment Modal
                 document.getElementById("comment-title").textContent = t.commentModalTitle;
                 const commentInput = document.getElementById("comment-input");
                 if(commentInput) commentInput.placeholder = t.commentInputPlaceholder;
                 const commentSaveBtn = document.getElementById('comment-save-btn');
                 if(commentSaveBtn) commentSaveBtn.textContent = t.saveButton;
                 const commentCancelBtn = document.getElementById('comment-cancel-btn');
                 if(commentCancelBtn) commentCancelBtn.textContent = t.cancelButton;
                 // --- START: Update new comment checkbox labels ---
                 const commentOptions = [
                     { value: "NoSeedsBC", key: "commentOptNoSeedsBC" },
                     { value: "OffensiveOverDefensive", key: "commentOptOffensiveOverDefensive" },
                     { value: "BuildKrouOffensive", key: "commentOptBuildKrouOffensive" },
                     { value: "BuildKrouDefensive", key: "commentOptBuildKrouDefensive" },
                     { value: "BlockOpponentKrou", key: "commentOptBlockOpponentKrou" },
                     { value: "BuildTwoKrous", key: "commentOptBuildTwoKrous" },
                     { value: "MultiCaptureLimit3", key: "commentOptMultiCaptureLimit3" },
                     { value: "MultiCaptureMax5", key: "commentOptMultiCaptureMax5" },
                     { value: "SpeedUpGame", key: "commentOptSpeedUpGame" },
                     { value: "SlowDownGame", key: "commentOptSlowDownGame" },
                     { value: "CaseToStudy", key: "commentOptCaseToStudy" },
                 ];
                 commentOptions.forEach(option => {
                     const spanElement = document.querySelector(`input[name="comment-option"][value="${option.value}"] + .checkbox-label-text`);
                     if (spanElement && t[option.key]) {
                         spanElement.textContent = t[option.key];
                     } else if (spanElement) {
                         // Fallback if translation is missing for the key, keep the default HTML text or show value
                         console.warn(`Translation missing for comment option key: ${option.key} in language: ${currentLanguage}`);
                     }
                 });
                 // --- END: Update new comment checkbox labels ---
                // Premium Modal (only if open, otherwise use function)
                if (document.getElementById('premium-info-modal').style.display === 'block') {
                    showPremiumInfoModal();
                } else {
                    const premiumCloseBtn = document.getElementById('premium-modal-close');
                    if (premiumCloseBtn) premiumCloseBtn.textContent = t.closeButton;
                }
            } catch (error) { console.error("Error updating static text elements:", error); }
            // Dynamic Content Updates
            populateGameSelect(); // Re-populates game dropdown with translated names
            renderBoard(); // Re-renders board with updated dynamic text
            console.log("Language update finished for:", currentLanguage);
        }
        // --- Fonctions de Configuration Jeu ---
        function populateGameSelect() {
            const select = document.getElementById("level-select");
            if (!select) { console.error("Level select element not found"); return; }
            const t = translations[currentLanguage] || translations.en;
            const currentSelectedIndex = select.value ? parseInt(select.value) : currentGameIndex;
            select.innerHTML = "";
            const maxGamesToShow = isPremium ? games.length : 3;
            const gamesToShowCount = Math.min(maxGamesToShow, games.length);
            const visibleGames = games.slice(0, Math.max(1, gamesToShowCount));
            visibleGames.forEach((game, index) => {
                const option = document.createElement("option");
                option.value = index;
                option.textContent = t.gameDropdownFormat(index + 1, game.length);
                select.appendChild(option);
            });
            if (select.options.length > 0) {
                 const validIndex = Math.min(currentSelectedIndex, select.options.length - 1);
                 const optionExists = Array.from(select.options).some(opt => parseInt(opt.value) === validIndex);
                 select.value = optionExists ? validIndex : 0;
             }
        }
        function changeLevel() {
            const select = document.getElementById("level-select");
            if (!select) return;
            const selectedValue = select.value;
            let potentialNewIndex = parseInt(selectedValue);
            const maxAllowedIndex = isPremium ? games.length - 1 : Math.min(2, games.length - 1);
            if (isNaN(potentialNewIndex) || potentialNewIndex < 0 || potentialNewIndex > maxAllowedIndex) {
                console.warn(`Invalid level selection ${selectedValue}. Max allowed: ${maxAllowedIndex}. Defaulting to 0.`);
                potentialNewIndex = 0;
                select.value = 0;
            }
            if (currentGameIndex !== potentialNewIndex || currentGame.length === 0) {
                currentGameIndex = potentialNewIndex;
                 if (games[currentGameIndex]) {
                     currentGame = games[currentGameIndex].split('');
                     restartGame();
                 } else {
                     console.error("Selected game data unexpectedly not found:", currentGameIndex, "Defaulting to 0.");
                     currentGameIndex = 0;
                     select.value = 0;
                     currentGame = games[0] ? games[0].split('') : [];
                     restartGame();
                 }
            }
        }
        function setDefaultBet() {
            const select = document.getElementById('bet-amount');
            if (select) {
                if (isBetLocked && lockedBetPercentage !== null) {
                    if (Array.from(select.options).some(opt => opt.value === lockedBetPercentage)) {
                        select.value = lockedBetPercentage;
                    } else {
                        console.warn(`Locked bet percentage ${lockedBetPercentage} not found. Unlocking.`);
                        isBetLocked = false;
                        lockedBetPercentage = null;
                        select.value = "75";
                    }
                    select.disabled = isBetLocked;
                } else {
                    isBetLocked = false;
                    lockedBetPercentage = null;
                    select.value = "75";
                    select.disabled = false;
                }
            }
        }
        // --- Fonction de Rendu Plateau (MODIFI√âE pour highlightDisabled) ---
        function renderBoard() {
            const t = translations[currentLanguage] || translations.en;
            try {
                const player1Row = document.getElementById('player1-row');
                const player2Row = document.getElementById('player2-row');
                if (!player1Row || !player2Row) { console.error("CRITICAL: #player1-row or #player2-row not found."); document.getElementById('result').textContent = t.errorDisplayMessage; return; }
                player1Row.innerHTML = '';
                player2Row.innerHTML = '';
                 if (!board || typeof board !== 'object' || !Array.isArray(board.player1) || !Array.isArray(board.player2) ||
                     !scores || typeof scores !== 'object' || typeof scores.player1 !== 'number' || typeof scores.player2 !== 'number') {
                     console.error("CRITICAL: Board or scores data is invalid or missing.", board, scores);
                     document.getElementById('result').textContent = t.errorDisplayMessage;
                     return;
                 }
                const betInput = document.getElementById('bet-input');
                const selectedBetCode = betInput ? betInput.value : null;
                const isCurrentlyGameOver = currentMoveIndex + 1 >= currentGame.length;
                isGameOver.confettiShown = isGameOver.confettiShown && isCurrentlyGameOver;
                const nextMoveCode = isCurrentlyGameOver ? null : currentGame[currentMoveIndex + 1];
                const isPlayer1Turn = !isCurrentlyGameOver && /[A-F]/.test(nextMoveCode);
                clearTimeout(animationTimeout);
                let capturedOpponentHolesIndices = [];
                let pressuredOpponentHolesIndices = [];
                let threatenedPlayer1HolesIndices = [];
                if (isPremium && areAidesEnabled && isPlayer1Turn && board.player1 && board.player2) {
                    if (selectedBetCode) {
                        const selectedIndex = holeMap[selectedBetCode];
                        if (selectedIndex !== undefined && board.player1[selectedIndex] > 0) {
                            const simResultP1 = simulateMove(selectedBetCode, { currentBoard: board, currentScores: scores });
                            if (simResultP1 && !simResultP1.error && Array.isArray(simResultP1.capturedHoles)) {
                                capturedOpponentHolesIndices = simResultP1.capturedHoles.filter(h => h.player === 2).map(h => h.index);
                                if (capturedOpponentHolesIndices.length === 0) {
                                    pressuredOpponentHolesIndices = analyzeFuturePressure(simResultP1.board, simResultP1.scores);
                                }
                            }
                        }
                    }
                    opponentHoleCodes.forEach((opponentMoveCode) => {
                        const opponentHoleIndex = holeMap[opponentMoveCode];
                        if (opponentHoleIndex !== undefined && board.player2[opponentHoleIndex] > 0) {
                             const simResultP2 = simulateMove(opponentMoveCode, { currentBoard: board, currentScores: scores });
                             if (simResultP2 && !simResultP2.error && Array.isArray(simResultP2.capturedHoles)) {
                                 const capturedP1Holes = simResultP2.capturedHoles.filter(h => h.player === 1).map(h => h.index);
                                 capturedP1Holes.forEach(threatIndex => {
                                     if (!threatenedPlayer1HolesIndices.includes(threatIndex)) {
                                         threatenedPlayer1HolesIndices.push(threatIndex);
                                     }
                                 });
                             }
                        }
                    });
                }
                 const turnIndicator = document.getElementById('turn-indicator');
                 if (turnIndicator) {
                     if (isCurrentlyGameOver) {
                         turnIndicator.textContent = "";
                         turnIndicator.className = "";
                     } else {
                         turnIndicator.textContent = isPlayer1Turn ? t.playerTurnIndicator : t.opponentTurnIndicator;
                         turnIndicator.className = isPlayer1Turn ? 'player-turn' : 'opponent-turn';
                     }
                 }
                board.player1.forEach((seeds, index) => {
                    const hole = document.createElement('div');
                    const holeCode = playerHoleCodes[index];
                    hole.className = 'hole player1-hole';
                    hole.textContent = seeds;
                    hole.dataset.code = holeCode;
                    const isClickable = isPlayer1Turn && seeds > 0;
                    if (isClickable) {
                        hole.classList.add('clickable');
                        hole.addEventListener('click', () => {
                            if (betInput) betInput.value = holeCode;
                            renderBoard();
                        });
                    } else if (isPlayer1Turn && seeds === 0) {
                         hole.classList.add('disabled');
                         hole.addEventListener('click', () => showTemporaryMessage(t.emptyHoleMessage));
                    } else if (!isPlayer1Turn) {
                        hole.classList.add('disabled');
                        hole.addEventListener('click', () => showTemporaryMessage(t.opponentTurnMessage));
                    }
                    // MODIFI√â: Ajout de la condition !highlightDisabled pour la surbrillance
                    if (holeCode === selectedBetCode && isPlayer1Turn && !highlightDisabled) hole.classList.add('selected-bet');
                    if (isPremium && areAidesEnabled && isPlayer1Turn && threatenedPlayer1HolesIndices.includes(index)) hole.classList.add('highlight-pressure-enabled');
                    if (holeCode === lastIncorrectGuess) hole.classList.add('highlight-incorrect');
                    if (holeCode === lastCorrectMove) hole.classList.add('highlight-correct');
                    if (highlightStartHole?.player === 1 && highlightStartHole?.index === index) hole.classList.add('highlight-start');
                    if (highlightEndHole?.player === 1 && highlightEndHole?.index === index) hole.classList.add('highlight-end');
                    player1Row.appendChild(hole);
                });
                const reversedPlayer2 = [...board.player2].reverse();
                reversedPlayer2.forEach((seeds, visualIndex) => {
                    const actualIndex = 5 - visualIndex;
                    const holeCode = opponentHoleCodes[actualIndex];
                    const hole = document.createElement('div');
                    hole.className = 'hole player2-hole';
                    hole.textContent = seeds;
                    hole.dataset.index = actualIndex;
                    hole.dataset.code = holeCode;
                    addLongPressListenerForSecrets(hole, actualIndex);
                    if (isPremium && areAidesEnabled && isPlayer1Turn) {
                        if (capturedOpponentHolesIndices.includes(actualIndex)) {
                            hole.classList.add('highlight-capture-enabled');
                        } else if (pressuredOpponentHolesIndices.includes(actualIndex)) {
                            hole.classList.add('highlight-pressure-enabled');
                        }
                    }
                    if (highlightStartHole?.player === 2 && highlightStartHole?.index === actualIndex) hole.classList.add('highlight-start');
                    if (highlightEndHole?.player === 2 && highlightEndHole?.index === actualIndex) hole.classList.add('highlight-end');
                    player2Row.appendChild(hole);
                });
                 const recordBtn = document.getElementById('record-btn');
                 const historyBtn = document.getElementById('history-btn');
                 if(recordBtn) recordBtn.style.display = isPremium ? 'inline-block' : 'none';
                 if(historyBtn) historyBtn.style.display = isPremium ? 'inline-block' : 'none';
                const moveInfoEl = document.getElementById('move-info');
                if (moveInfoEl) moveInfoEl.textContent = t.moveInfo(scores.player1, scores.player2);
                const betPotInfoEl = document.getElementById('bet-pot-info');
                if (betPotInfoEl) betPotInfoEl.innerHTML = t.betPotInfo(pot);
                const successRateEl = document.getElementById('success-rate');
                if (successRateEl) {
                    const rate = totalPlayer1Bets === 0 ? 0 : Math.round((successfulBets / totalPlayer1Bets) * 100);
                    successRateEl.innerHTML = t.successRate(rate);
                }
                const playedMovesEl = document.getElementById('played-moves');
                 if (playedMovesEl) {
                     const movesToShow = Array.isArray(playedMoves) ? playedMoves.slice(-10).join(' ') : '';
                     playedMovesEl.textContent = t.playedMoves(currentMoveIndex + 1, currentGame.length, movesToShow);
                 }
                const betButton = document.getElementById('bet-and-verify-btn');
                const nextButton = document.getElementById('next-btn');
                const resultEl = document.getElementById('result');
                if (betButton && nextButton && resultEl) {
                    if (isCurrentlyGameOver) {
                        betButton.style.display = 'none';
                        nextButton.style.display = 'none';
                         if (!resultEl.textContent.includes(t.resultWin) && !resultEl.textContent.includes(t.resultLose) && resultEl.style.color !== 'rgb(23, 162, 184)') {
                                if (!resultEl.textContent.startsWith(t.resultGameOver)) {
                                    resultEl.textContent = t.resultGameOver;
                                    resultEl.style.color = '#ff0000';
                                }
                         }
                        if (totalPlayer1Bets > 0 && successfulBets === totalPlayer1Bets && pot > 100 && !isGameOver.confettiShown) {
                             perfectGamesCount++;
                             rainConfetti();
                             isGameOver.confettiShown = true;
                             const messages = t.encouragingMessages || translations.en.encouragingMessages;
                             const messageIndex = Math.min(perfectGamesCount - 1, messages.length - 1);
                             setTimeout(() => {
                                 const resEl = document.getElementById('result');
                                 if (resEl && resEl.textContent.startsWith(t.resultGameOver)) {
                                     resEl.textContent = t.resultGameOver + " " + messages[messageIndex];
                                     resEl.style.color = '#008000';
                                 }
                             }, 2500);
                        }
                    } else {
                        betButton.style.display = isPlayer1Turn ? 'inline-block' : 'none';
                        nextButton.style.display = isPlayer1Turn ? 'none' : 'inline-block';
                        if (resultEl.textContent.startsWith(t.resultGameOver)) {
                            resultEl.textContent = "";
                        }
                    }
                }
                if (betInput) { betInput.onchange = () => renderBoard(); }
                applyCrossVisibility();
            } catch (error) {
                 console.error("Error during renderBoard:", error);
                 const t = translations[currentLanguage] || translations.en;
                 const resultEl = document.getElementById('result');
                 if (resultEl) { resultEl.textContent = t.errorDisplayMessage; resultEl.style.color = "red"; }
                 clearTimeout(animationTimeout);
             }
        }
        // --- Fonctions Logiques (Identiques √† la version pr√©c√©dente) ---
        function simulateMove(moveCode, options = {}) {
            const { currentBoard = board, currentScores = scores } = options;
            let tempBoard, tempScores;
            const t = translations[currentLanguage] || translations.en;
            try {
                tempBoard = JSON.parse(JSON.stringify(currentBoard));
                tempScores = JSON.parse(JSON.stringify(currentScores));
                 if (!tempBoard?.player1 || !tempBoard?.player2 || !tempScores ||
                     !Array.isArray(tempBoard.player1) || !tempBoard.player1.length === 6 ||
                     !Array.isArray(tempBoard.player2) || !tempBoard.player2.length === 6 ||
                     typeof tempScores.player1 !== 'number' || typeof tempScores.player2 !== 'number') {
                      console.error("Invalid board/scores structure provided to simulateMove", currentBoard, currentScores);
                      const safeBoard = initialBoard(); const safeScores = initialScores();
                      return { board: safeBoard, scores: safeScores, startHole: null, endHole: null, captured: 0, capturedHoles: [], error: true };
                 }
                const isPlayer1 = /[A-F]/.test(moveCode);
                const playerBoard = isPlayer1 ? tempBoard.player1 : tempBoard.player2;
                const opponentBoard = isPlayer1 ? tempBoard.player2 : tempBoard.player1;
                const holeIndex = holeMap[moveCode];
                if (holeIndex === undefined || holeIndex < 0 || holeIndex > 5 || !playerBoard || playerBoard[holeIndex] === undefined || playerBoard[holeIndex] <= 0) {
                    console.warn(`SimulateMove invalid start: ${moveCode} from hole ${holeIndex} with ${playerBoard ? playerBoard[holeIndex] : 'N/A'} seeds.`);
                     return { board: JSON.parse(JSON.stringify(currentBoard)), scores: JSON.parse(JSON.stringify(currentScores)), startHole: { player: isPlayer1 ? 1 : 2, index: holeIndex }, endHole: { player: isPlayer1 ? 1 : 2, index: holeIndex }, captured: 0, capturedHoles: [], error: true };
                }
                const startHole = { player: isPlayer1 ? 1 : 2, index: holeIndex };
                let seeds = playerBoard[holeIndex];
                playerBoard[holeIndex] = 0;
                let currentPlayer = isPlayer1 ? 1 : 2;
                let currentHole = holeIndex;
                let seedsToDistribute = seeds;
                let lastHole = null;
                 while (seedsToDistribute > 0) {
                    if (currentPlayer === 1) {
                        currentHole++;
                        if (currentHole > 5) {
                            currentPlayer = 2;
                            currentHole = 0;
                        }
                    } else {
                        currentHole++;
                        if (currentHole > 5) {
                            currentPlayer = 1;
                            currentHole = 0;
                        }
                    }
                    const isStartingHole = (isPlayer1 && currentPlayer === 1 && currentHole === holeIndex) || (!isPlayer1 && currentPlayer === 2 && currentHole === holeIndex);
                    if (!(seeds >= 12 && isStartingHole)) {
                        if (currentPlayer === 1) tempBoard.player1[currentHole]++;
                        else tempBoard.player2[currentHole]++;
                        seedsToDistribute--;
                    }
                    if (seedsToDistribute === 0) {
                        lastHole = { player: currentPlayer, index: currentHole };
                    }
                }
                const endHole = lastHole || startHole;
                let capturedSeedsTotal = 0;
                let capturedHolesPath = [];
                const landedPlayer = lastHole ? lastHole.player : (isPlayer1 ? 1 : 2);
                const landedHoleIndex = lastHole ? lastHole.index : holeIndex;
                if (lastHole && ((isPlayer1 && landedPlayer === 2) || (!isPlayer1 && landedPlayer === 1)))
                {
                    let newBoardForCheck = JSON.parse(JSON.stringify(tempBoard));
                    let tempCapturedInLoop = 0;
                    let currentCapturePathDetails = [];
                    if (isPlayer1 && landedPlayer === 2) {
                        let capturePos = landedHoleIndex;
                        while (capturePos >= 0 && (tempBoard.player2[capturePos] === 2 || tempBoard.player2[capturePos] === 3)) {
                            const seedsInHole = tempBoard.player2[capturePos];
                            tempCapturedInLoop += seedsInHole;
                            currentCapturePathDetails.push({ index: capturePos, player: 2, value: seedsInHole });
                            newBoardForCheck.player2[capturePos] = 0;
                            capturePos--;
                        }
                        if (tempCapturedInLoop > 0 && !newBoardForCheck.player2.every(s => s === 0)) {
                             capturedSeedsTotal = tempCapturedInLoop;
                             capturedHolesPath = currentCapturePathDetails;
                             capturedHolesPath.forEach(holeInfo => { tempBoard.player2[holeInfo.index] = 0; });
                             tempScores.player1 += capturedSeedsTotal;
                        }
                    }
                    else if (!isPlayer1 && landedPlayer === 1) {
                         let capturePos = landedHoleIndex;
                         while (capturePos >= 0 && (tempBoard.player1[capturePos] === 2 || tempBoard.player1[capturePos] === 3)) {
                             const seedsInHole = tempBoard.player1[capturePos];
                             tempCapturedInLoop += seedsInHole;
                             currentCapturePathDetails.push({ index: capturePos, player: 1, value: seedsInHole });
                             newBoardForCheck.player1[capturePos] = 0;
                             capturePos--;
                        }
                        if (tempCapturedInLoop > 0 && !newBoardForCheck.player1.every(s => s === 0)) {
                            capturedSeedsTotal = tempCapturedInLoop;
                            capturedHolesPath = currentCapturePathDetails;
                            capturedHolesPath.forEach(holeInfo => { tempBoard.player1[holeInfo.index] = 0; });
                            tempScores.player2 += capturedSeedsTotal;
                        }
                    }
                }
                return {
                    board: tempBoard,
                    scores: tempScores,
                    startHole: startHole,
                    endHole: endHole,
                    captured: capturedSeedsTotal,
                    capturedHoles: capturedHolesPath,
                    error: false
                };
            } catch (error) {
                console.error("Error during simulateMove:", error, moveCode, currentBoard);
                showTemporaryMessage(t.internalErrorMessage);
                const safeBoard = initialBoard();
                const safeScores = initialScores();
                 return { board: safeBoard, scores: safeScores, startHole: null, endHole: null, captured: 0, capturedHoles: [], error: true };
            }
        }
        function analyzeFuturePressure(simulatedBoard, simulatedScores) {
             const pressurePoints = [];
             const opponentPlayer = 2;
             if (!simulatedBoard?.player2) return [];
             const vulnerableHolesIndices = simulatedBoard.player2.reduce((acc, seeds, index) => {
                 if (seeds === 1 || seeds === 2) acc.push(index);
                 return acc;
             }, []);
             if (vulnerableHolesIndices.length === 0) return [];
             if (!simulatedBoard?.player1) return [];
             for (let playerHoleIndex = 0; playerHoleIndex < playerHoleCodes.length; playerHoleIndex++) {
                 const playerSeeds = simulatedBoard.player1[playerHoleIndex];
                 if (playerSeeds > 0) {
                     const potentialNextMoveCode = playerHoleCodes[playerHoleIndex];
                     const nextSimResult = simulateMove(potentialNextMoveCode, {
                         currentBoard: simulatedBoard,
                         currentScores: simulatedScores
                     });
                     if (nextSimResult && !nextSimResult.error && Array.isArray(nextSimResult.capturedHoles)) {
                         const capturedByThisNextMove = nextSimResult.capturedHoles
                             .filter(h => h.player === opponentPlayer)
                             .map(h => h.index);
                         vulnerableHolesIndices.forEach(vulnIndex => {
                             if (capturedByThisNextMove.includes(vulnIndex) && !pressurePoints.includes(vulnIndex)) {
                                 pressurePoints.push(vulnIndex);
                             }
                         });
                     }
                 }
                 if (pressurePoints.length === vulnerableHolesIndices.length) break;
             }
             return pressurePoints;
        }
        function betAndVerify() {
             const t = translations[currentLanguage] || translations.en;
             const betInput = document.getElementById('bet-input');
             if (!betInput) return;
             currentBet = betInput.value;
             const betSelect = document.getElementById('bet-amount');
             if (!betSelect) return;
             let betPercentage = parseInt(betSelect.value);
             if (isNaN(betPercentage) || betPercentage <= 0 || betPercentage > 100) {
                 showTemporaryMessage(t.resultInvalidBet + " (%)");
                 return;
             }
             if (isNaN(pot)) pot = 100;
             betAmount = Math.max(0, Math.floor(pot * (betPercentage / 100)));
             if ((betAmount <= 0 && pot > 0) || betAmount > pot) {
                 showTemporaryMessage(t.resultInvalidBet + " (Amount/Funds)");
                 return;
             }
             if (currentMoveIndex + 1 >= currentGame.length) {
                 showTemporaryMessage(t.resultGameOver);
                 return;
             }
             const nextMove = currentGame[currentMoveIndex + 1];
             const isPlayer1Next = /[A-F]/.test(nextMove);
             if (!isPlayer1Next) {
                 showTemporaryMessage(t.notYourTurnMessage);
                 return;
             }
             const currentBetIndex = holeMap[currentBet];
             if (currentBetIndex === undefined || !board?.player1 || board.player1[currentBetIndex] === undefined || board.player1[currentBetIndex] <= 0) {
                 showTemporaryMessage(t.invalidHoleMessage);
                 return;
             }
             document.getElementById('result').textContent = "";
             lastIncorrectGuess = null;
             lastCorrectMove = null;
             currentMoveIndex++;
             totalPlayer1Bets++;
             if (!Array.isArray(playedMoves)) playedMoves = [];
             playedMoves.push(nextMove);
             if (totalPlayer1Bets === 1 && currentMoveIndex === 0) {
                 startNewGameRecord();
             }
             if (!Array.isArray(moveHistory)) moveHistory = [];
             moveHistory.push({
                 board: JSON.parse(JSON.stringify(board)),
                 scores: JSON.parse(JSON.stringify(scores)),
                 moveCode: nextMove
             });
             const moveResult = simulateMove(nextMove, { currentBoard: board, currentScores: scores });
              if (!moveResult || moveResult.error) {
                  console.error("Simulation failed for the correct player move:", nextMove);
                  moveHistory.pop();
                  currentMoveIndex--;
                  totalPlayer1Bets--;
                  if (playedMoves.length > 0) playedMoves.pop();
                  showTemporaryMessage(t.internalErrorMessage);
                  renderBoard();
                  return;
              }
              board = moveResult.board;
              scores = moveResult.scores;
             triggerAnimation(moveResult.startHole, moveResult.endHole);
             const resultEl = document.getElementById('result');
             if (isSuccessGuaranteed || currentBet === nextMove) {
                 pot = Math.round(pot + betAmount);
                 successfulBets++;
                 if (resultEl) {
                     resultEl.textContent = t.resultWin;
                     resultEl.style.color = '#008000';
                 }
             } else {
                 pot = Math.max(0, Math.round(pot - betAmount));
                 if (resultEl) {
                     resultEl.textContent = `${t.resultLose} (${nextMove})`;
                     resultEl.style.color = '#ff0000';
                 }
                 lastIncorrectGuess = currentBet;
                 lastCorrectMove = nextMove;
                 const errorData = {
                      moveIndex: currentMoveIndex,
                      bet: currentBet,
                      correctMove: nextMove,
                      potChange: -betAmount,
                      betAmount: betAmount,
                      timestamp: Date.now()
                 };
                 if (!Array.isArray(errorLog)) errorLog = [];
                 errorLog.push(errorData);
                 if (currentGameRecord && Array.isArray(currentGameRecord.errors)) {
                     currentGameRecord.errors.push(errorData);
                 }
             }
             setDefaultBet();
             renderBoard();
             const isNowGameOver = currentMoveIndex + 1 >= currentGame.length;
             if (isNowGameOver && currentGameRecord.startTime && !currentGameRecord.endTime) {
                 console.log("Calling finalizeGameRecord from betAndVerify after game end.");
                 finalizeGameRecord();
             }
        }
        function moveNext() {
             const t = translations[currentLanguage] || translations.en;
             if (currentMoveIndex + 1 >= currentGame.length) {
                 showTemporaryMessage(t.resultGameOver);
                 return;
             }
             const nextMove = currentGame[currentMoveIndex + 1];
             const isPlayer1Next = /[A-F]/.test(nextMove);
             if (isPlayer1Next) {
                 showTemporaryMessage(t.playerTurnIndicator);
                 return;
             }
             document.getElementById('result').textContent = "";
             lastIncorrectGuess = null;
             lastCorrectMove = null;
             currentMoveIndex++;
             if (!Array.isArray(playedMoves)) playedMoves = [];
             playedMoves.push(nextMove);
             if (currentMoveIndex === 0 && totalPlayer1Bets === 0) {
                 startNewGameRecord();
             }
             if (!Array.isArray(moveHistory)) moveHistory = [];
             moveHistory.push({
                 board: JSON.parse(JSON.stringify(board)),
                 scores: JSON.parse(JSON.stringify(scores)),
                 moveCode: nextMove
             });
              const moveResult = simulateMove(nextMove, { currentBoard: board, currentScores: scores });
             if (!moveResult || moveResult.error) {
                  console.error("Simulation failed for opponent move:", nextMove);
                  moveHistory.pop();
                  currentMoveIndex--;
                  if (playedMoves.length > 0) playedMoves.pop();
                  showTemporaryMessage(t.internalErrorMessage);
                  renderBoard();
                  return;
             }
               board = moveResult.board;
               scores = moveResult.scores;
             triggerAnimation(moveResult.startHole, moveResult.endHole);
             setDefaultBet();
             renderBoard();
             const isNowGameOver = currentMoveIndex + 1 >= currentGame.length;
             if (isNowGameOver && currentGameRecord.startTime && !currentGameRecord.endTime) {
                 console.log("Calling finalizeGameRecord from moveNext after game end.");
                 finalizeGameRecord();
             }
        }
        function triggerAnimation(startHole, endHole) {
             clearTimeout(animationTimeout);
             highlightStartHole = startHole;
             highlightEndHole = endHole;
             renderBoard();
             animationTimeout = setTimeout(() => {
                 highlightStartHole = null;
                 highlightEndHole = null;
                 renderBoard();
             }, 800);
        }
        // --- Fonctions Historique, Commentaires, Enregistrements (Identiques √† la version pr√©c√©dente) ---
        function startNewGameRecord() {
            if (currentGameRecord.startTime && !currentGameRecord.endTime) {
                console.log("Finalizing previous unfinished record before starting new one.");
                finalizeGameRecord();
            }
            gameStartTime = Date.now();
            const t = translations[currentLanguage] || translations.en;
            currentGameRecord = {
                gameId: `game-${currentGameIndex + 1}-${gameStartTime}`,
                gameName: t.gameDropdownFormat(currentGameIndex + 1, currentGame.length),
                totalMoves: currentGame.length,
                startTime: gameStartTime,
                endTime: null,
                duration: 0,
                successRate: 0,
                finalPot: pot,
                comments: [],
                errors: []
            };
            errorLog = [];
            console.log("Started new game record:", currentGameRecord.gameId);
        }
        function finalizeGameRecord() {
            if (!currentGameRecord || !currentGameRecord.startTime || currentGameRecord.endTime) {
                 console.log("Skipping finalizeGameRecord: No active/unfinished record.");
                 if(currentGameRecord && !currentGameRecord.startTime) currentGameRecord = {};
                return;
            }
            console.log("Finalizing game record:", currentGameRecord.gameId);
            currentGameRecord.endTime = Date.now();
            currentGameRecord.duration = Math.round((currentGameRecord.endTime - currentGameRecord.startTime) / 1000);
            currentGameRecord.successRate = totalPlayer1Bets === 0 ? 0 : Math.round((successfulBets / totalPlayer1Bets) * 100);
            currentGameRecord.finalPot = pot;
            currentGameRecord.errors = [...errorLog];
            const existingIndex = gameRecords.findIndex(r => r.gameId === currentGameRecord.gameId);
            if (existingIndex > -1) {
                gameRecords[existingIndex] = { ...currentGameRecord };
                console.log("Updated existing game record:", currentGameRecord.gameId);
            } else {
                gameRecords.push({ ...currentGameRecord });
                console.log("Added new game record:", currentGameRecord.gameId);
            }
            saveGameRecords();
            currentGameRecord = {};
            gameStartTime = null;
            errorLog = [];
            console.log("Game record finalized and saved.");
        }
        function restartGame() {
            finalizeGameRecord();
            board = initialBoard();
            scores = initialScores();
            currentMoveIndex = -1;
            moveHistory = [{ board: JSON.parse(JSON.stringify(board)), scores: JSON.parse(JSON.stringify(scores)), moveCode: null }];
            currentBet = null;
            playedMoves = [];
            pot = 100;
            successfulBets = 0;
            totalPlayer1Bets = 0;
            errorLog = [];
            gameStartTime = null;
            currentGameRecord = {};
            lastIncorrectGuess = null;
            lastCorrectMove = null;
            highlightStartHole = null;
            highlightEndHole = null;
            clearTimeout(animationTimeout);
            isGameOver.confettiShown = false;
            const resultEl = document.getElementById('result');
            if (resultEl) resultEl.textContent = "";
            const secretMsgEl = document.getElementById('secret-message');
            if (secretMsgEl) secretMsgEl.textContent = "";
            setDefaultBet();
             if (games[currentGameIndex]) {
                 currentGame = games[currentGameIndex].split('');
             } else {
                 console.error(`Game index ${currentGameIndex} invalid after restart. Defaulting to 0.`);
                 currentGameIndex = 0;
                 currentGame = games[0] ? games[0].split('') : [];
                 const levelSelect = document.getElementById('level-select');
                 if(levelSelect) levelSelect.value = 0;
             }
            renderBoard();
            console.log("Game restarted. Level:", currentGameIndex + 1);
        }
        function openCommentModal() {
            if (!isPremium) { showPremiumInfoModal(); return; }
            const modal = document.getElementById('comment-modal'); if (modal) modal.style.display = 'block';
            const commentInput = document.getElementById('comment-input'); if (commentInput) commentInput.value = '';
            document.querySelectorAll('input[name="comment-option"]').forEach(checkbox => checkbox.checked = false);
             // Make sure labels are in the correct language when opening
             updateLanguage(); // Re-run to ensure comment labels are translated
        }
        function saveComment() {
             if (!currentGameRecord || !currentGameRecord.startTime) {
                 console.warn("Cannot save comment: No active game record.");
                 closeModal('comment-modal');
                 return;
             }
             const commentInput = document.getElementById('comment-input');
             const checkboxes = document.querySelectorAll('input[name="comment-option"]:checked');
             let commentText = commentInput ? commentInput.value.trim() : '';
             const checkedOptions = Array.from(checkboxes).map(checkbox => {
                 const labelSpan = checkbox.nextElementSibling;
                 return labelSpan ? labelSpan.textContent.trim() : checkbox.value;
             });
             if (commentText || checkedOptions.length > 0) {
                 const moveIndexForLabel = currentMoveIndex >= 0 ? currentMoveIndex + 1 : 0;
                 const moveLabel = moveIndexForLabel > 0 ? `${moveIndexForLabel}/${currentGame.length}` : "Start";
                 const moveCodePlayed = currentMoveIndex >= 0 ? currentGame[currentMoveIndex] : null;
                 const fullComment = {
                     move: moveLabel,
                     moveCode: moveCodePlayed,
                     timestamp: Date.now(),
                     text: commentText,
                     options: checkedOptions
                 };
                 if (!Array.isArray(currentGameRecord.comments)) {
                     currentGameRecord.comments = [];
                 }
                 currentGameRecord.comments.push(fullComment);
                 console.log("Comment saved for move:", moveLabel);
             }
             closeModal('comment-modal');
        }
        function openHistoryModal() {
             if (!isPremium) { showPremiumInfoModal(); return; }
             const t = translations[currentLanguage] || translations.en;
             const historyContent = document.getElementById('history-content');
             const historyModal = document.getElementById('history-modal');
             if (!historyContent || !historyModal) { console.error("History modal elements not found"); return;}
             historyContent.innerHTML = '';
             const tempRecords = [...gameRecords];
             if (currentGameRecord && currentGameRecord.startTime && !currentGameRecord.endTime) {
                 const currentSnapshot = {
                     ...currentGameRecord,
                     endTime: Date.now(),
                     duration: Math.round((Date.now() - currentGameRecord.startTime) / 1000),
                     finalPot: pot,
                     successRate: totalPlayer1Bets === 0 ? 0 : Math.round((successfulBets / totalPlayer1Bets) * 100),
                     errors: [...errorLog],
                     comments: [...(currentGameRecord.comments || [])],
                     isInProgress: true
                 };
                 tempRecords.push(currentSnapshot);
             }
             tempRecords.sort((a, b) => (b.startTime || 0) - (a.startTime || 0));
             if (tempRecords.length === 0) {
                 historyContent.textContent = t.noHistory;
             } else {
                 tempRecords.forEach(record => {
                      if (!record || !record.startTime) return;
                     const entryDetails = document.createElement('details');
                     entryDetails.className = 'history-entry';
                     const entrySummary = document.createElement('summary');
                     entrySummary.className = 'history-summary';
                     const gameDate = new Date(record.startTime).toLocaleString(currentLanguage, { dateStyle: 'short', timeStyle: 'short' });
                     const titleText = t.historyRecordTitle(record.gameName || `Game ID ${record.gameId}`, gameDate);
                     const statsText = t.historyStats(record.successRate ?? 0, record.finalPot ?? 0, record.duration ?? 0);
                     const inProgressText = record.isInProgress ? ` <em style="color: #007bff;font-size:0.9em;">${t.historyInProgress}</em>` : '';
                     entrySummary.innerHTML = `<span style="flex-grow: 1;">${titleText} <span style="font-weight:normal; font-size:0.9em;">(${statsText})</span></span>${inProgressText}`;
                     entryDetails.appendChild(entrySummary);
                     const detailsDiv = document.createElement('div');
                     detailsDiv.className = 'history-details';
                     const commentsTitle = document.createElement('h4');
                     commentsTitle.textContent = t.historyCommentsTitle;
                     detailsDiv.appendChild(commentsTitle);
                     if (record.comments && record.comments.length > 0) {
                         record.comments.forEach(comment => {
                             const commentP = document.createElement('p');
                             commentP.className = 'comment-entry';
                             const commentDate = new Date(comment.timestamp).toLocaleTimeString(currentLanguage, { timeStyle: 'short' });
                             let optionsText = comment.options && comment.options.length > 0 ? ` [${comment.options.join(', ')}]` : '';
                             const moveLabel = t.historyMoveLabel;
                             commentP.innerHTML = `<strong>${moveLabel} ${comment.move || '?'} (${comment.moveCode || 'N/A'}):</strong> ${comment.text || ''}<span class="comment-options">${optionsText}</span> <small>(${commentDate})</small>`;
                             detailsDiv.appendChild(commentP);
                         });
                     } else {
                         const noCommentP = document.createElement('p');
                         noCommentP.textContent = t.historyNoComments;
                         noCommentP.style.fontStyle = 'italic';
                         detailsDiv.appendChild(noCommentP);
                     }
                     const errorsTitle = document.createElement('h4');
                     errorsTitle.textContent = t.historyErrorsTitle;
                     errorsTitle.style.marginTop = '15px';
                     detailsDiv.appendChild(errorsTitle);
                     if (record.errors && record.errors.length > 0) {
                         record.errors.forEach(error => {
                             const errorP = document.createElement('p');
                             errorP.className = 'error-entry';
                             const errorDate = new Date(error.timestamp).toLocaleTimeString(currentLanguage, { timeStyle: 'short' });
                              const moveLabel = t.historyMoveLabel;
                              const errorMoveNumber = (typeof error.moveIndex === 'number' && error.moveIndex >= 0) ? error.moveIndex + 1 : '?';
                              errorP.innerHTML = `<strong>${moveLabel} ${errorMoveNumber}:</strong> ${t.historyBetErrorLabel(error.bet, error.correctMove, error.potChange, errorDate)}`;
                             detailsDiv.appendChild(errorP);
                         });
                     } else {
                         const noErrorP = document.createElement('p');
                         noErrorP.textContent = t.historyNoErrors;
                         noErrorP.style.fontStyle = 'italic';
                         detailsDiv.appendChild(noErrorP);
                     }
                     entryDetails.appendChild(detailsDiv);
                     historyContent.appendChild(entryDetails);
                 });
             }
             historyModal.style.display = 'block';
        }
        function copyHistoryContent() {
             const t = translations[currentLanguage] || translations.en;
             try {
                 const dynamicPromptMap = {
                     fr: `Vous √™tes un expert Awal√© et coach strat√©gique sp√©cialis√© dans l'analyse des parties de champions. Voici l'historique des parties jou√©es par un utilisateur essayant de deviner le coup du champion. Analysez ses performances, ses erreurs courantes (le tableau 'errors' montre son pari incorrect par rapport au coup correct), ses points forts et ses commentaires (le tableau 'comments' contient des notes utilisateur avec potentiellement des options coch√©es comme 'Acc√©l√©rer le jeu', 'Bloquer le Contre-Krou Adverse', etc.). Fournissez des commentaires constructifs et des conseils de coaching pour l'aider √† am√©liorer sa capacit√© √† penser comme le champion.\nIMPORTANT : Veuillez formuler votre r√©ponse exclusivement dans la langue suivante : Fran√ßais.`,
                     en: `You are an Awale expert and strategic coach specialized in analyzing champion games. Here is the history of games played by a user trying to guess the champion's move. Analyze their performance, common mistakes (the 'errors' array shows their incorrect bet vs the correct move), strengths, and comments (the 'comments' array contains user notes, potentially with checked options like 'Acc√©l√©rer le jeu' [Speed up game], 'Bloquer le Contre-Krou Adverse' [Block Opponent Krou], etc.). Provide constructive feedback and coaching tips to help them improve their ability to think like the champion.\nIMPORTANT: Please formulate your response exclusively in the following language: English.`,
                     es: `Eres un experto en Awal√© y entrenador estrat√©gico especializado en analizar partidas de campeones. Aqu√≠ tienes el historial de partidas jugadas por un usuario que intenta adivinar la jugada del campe√≥n. Analiza su rendimiento, errores comunes (la matriz 'errors' muestra su apuesta incorrecta frente a la jugada correcta), puntos fuertes y comentarios (la matriz 'comments' contiene notas del usuario, potencialmente con opciones marcadas como 'Acc√©l√©rer le jeu' [Acelerar el juego], 'Bloquer le Contre-Krou Adverse' [Bloquear Contra-Krou Adversario], etc.). Proporciona comentarios constructivos y consejos de coaching para ayudarle a mejorar su capacidad de pensar como el campe√≥n.\nIMPORTANTE: Por favor, formula tu respuesta exclusivamente en el siguiente idioma: Espa√±ol.`,
                     ru: `–í—ã —ç–∫—Å–ø–µ—Ä—Ç –ø–æ –ê–≤–∞–ª–µ –∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–π —Ç—Ä–µ–Ω–µ—Ä, —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é—â–∏–π—Å—è –Ω–∞ –∞–Ω–∞–ª–∏–∑–µ –∏–≥—Ä —á–µ–º–ø–∏–æ–Ω–æ–≤. –í–æ—Ç –∏—Å—Ç–æ—Ä–∏—è –∏–≥—Ä, —Å—ã–≥—Ä–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º, –ø—ã—Ç–∞—é—â–∏–º—Å—è —É–≥–∞–¥–∞—Ç—å —Ö–æ–¥ —á–µ–º–ø–∏–æ–Ω–∞. –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã, —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏ (–º–∞—Å—Å–∏–≤ 'errors' –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –µ–≥–æ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—É—é —Å—Ç–∞–≤–∫—É –ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —Ö–æ–¥–æ–º), —Å–∏–ª—å–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã –∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ (–º–∞—Å—Å–∏–≤ 'comments' —Å–æ–¥–µ—Ä–∂–∏—Ç –∑–∞–º–µ—Ç–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –≤–æ–∑–º–æ–∂–Ω–æ, —Å –æ—Ç–º–µ—á–µ–Ω–Ω—ã–º–∏ –æ–ø—Ü–∏—è–º–∏, —Ç–∞–∫–∏–º–∏ –∫–∞–∫ 'Acc√©l√©rer le jeu' [–£—Å–∫–æ—Ä–∏—Ç—å –∏–≥—Ä—É], 'Bloquer le Contre-Krou Adverse' [–ë–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ö–æ–Ω—Ç—Ä-–ö—Ä—É –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞] –∏ —Ç.–¥.). –ü—Ä–µ–¥–æ—Å—Ç–∞–≤—å—Ç–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–∏–≤–Ω—É—é –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å –∏ —Ç—Ä–µ–Ω–µ—Ä—Å–∫–∏–µ —Å–æ–≤–µ—Ç—ã, —á—Ç–æ–±—ã –ø–æ–º–æ—á—å –µ–º—É —É–ª—É—á—à–∏—Ç—å —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –¥—É–º–∞—Ç—å –∫–∞–∫ —á–µ–º–ø–∏–æ–Ω.\n–í–ê–ñ–ù–û: –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ñ–æ—Ä–º—É–ª–∏—Ä—É–π—Ç–µ —Å–≤–æ–π –æ—Ç–≤–µ—Ç –∏—Å–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–º —è–∑—ã–∫–µ: –†—É—Å—Å–∫–∏–π.`,
                     zh: `ÊÇ®ÊòØ‰∏Ä‰Ωç Awale ‰∏ìÂÆ∂ÂíåÊàòÁï•ÊïôÁªÉÔºå‰∏ìÈó®ÂàÜÊûêÂÜ†ÂÜõÊ£ãÂ±Ä„ÄÇËøôÊòØ‰∏Ä‰ΩçËØïÂõæÁåúÊµãÂÜ†ÂÜõËµ∞Ê≥ïÁöÑÁî®Êà∑ÁöÑ‰∏ãÊ£ãÂéÜÂè≤ËÆ∞ÂΩï„ÄÇËØ∑ÂàÜÊûê‰ªñ‰ª¨ÁöÑË°®Áé∞„ÄÅÂ∏∏ËßÅÈîôËØØÔºà'errors' Êï∞ÁªÑÊòæÁ§∫‰∫Ü‰ªñ‰ª¨ÈîôËØØÁöÑ‰∏ãÊ≥®‰∏éÊ≠£Á°ÆËµ∞Ê≥ïÔºâ„ÄÅ‰ºòÁÇπÂíåËØÑËÆ∫Ôºà'comments' Êï∞ÁªÑÂåÖÂê´Áî®Êà∑Á¨îËÆ∞ÔºåÂèØËÉΩÂ∏¶ÊúâÈÄâ‰∏≠ÁöÑÈÄâÈ°πÔºå‰æãÂ¶Ç 'Acc√©l√©rer le jeu' [Âä†Âø´Ê∏∏Êàè]„ÄÅ'Bloquer le Contre-Krou Adverse' [ÈòªÊ≠¢ÂØπÊâãÂèçÂ∫ìÈ≤Å] Á≠âÔºâ„ÄÇÊèê‰æõÂª∫ËÆæÊÄßÁöÑÂèçÈ¶àÂíåÊåáÂØºÊäÄÂ∑ßÔºåÂ∏ÆÂä©‰ªñ‰ª¨ÊèêÈ´òÂÉèÂÜ†ÂÜõ‰∏ÄÊ†∑ÊÄùËÄÉÁöÑËÉΩÂäõ„ÄÇ\nÈáçË¶ÅÊèêÁ§∫ÔºöËØ∑‰ªÖ‰ΩøÁî®‰ª•‰∏ãËØ≠Ë®ÄÂà∂ÂÆöÊÇ®ÁöÑÂõûÂ§çÔºö‰∏≠Êñá„ÄÇ`
                 };
                 const dynamicPrompt = dynamicPromptMap[currentLanguage] || dynamicPromptMap.en;
                 const dataToCopy = {
                     prompt: dynamicPrompt,
                     language_preference: currentLanguage,
                     games: [...gameRecords]
                 };
                 const historyJson = JSON.stringify(dataToCopy, null, 2);
                 navigator.clipboard.writeText(historyJson).then(() => {
                     alert(t.copySuccess);
                 }).catch(err => {
                     console.error('Clipboard write error:', err);
                     alert(t.copyError);
                 });
             } catch (e) {
                 console.error("Error preparing history for copying:", e);
                 alert(t.copyPrepareError);
             }
        }
        function resetHistory() {
             const t = translations[currentLanguage] || translations.en;
             if (confirm(t.confirmResetHistory)) {
                 gameRecords = [];
                 localStorage.removeItem('awaleGameRecords');
                 const historyContent = document.getElementById('history-content');
                 if (historyContent) historyContent.textContent = t.noHistory;
                 closeModal('history-modal');
                 alert(t.historyResetSuccess);
             }
        }
        function rainConfetti() {
            const container = document.body;
            for (let i = 0; i < 150; i++) {
                 let c=document.createElement('div'); c.className='confetti';
                 const s=Math.random()*8+4; c.style.width=s+'px'; c.style.height=s+'px';
                 c.style.left=Math.random()*100+'vw';
                 c.style.top='-10px';
                 c.style.backgroundColor=`hsl(${Math.random()*360},100%,70%)`;
                 c.style.animationDuration=(Math.random()*3+2)+'s';
                 c.style.animationDelay=Math.random()*1+'s';
                 c.style.transform=`rotate(${Math.random()*360}deg)`;
                 container.appendChild(c);
                 c.addEventListener('animationend',()=>{if(c.parentNode)c.parentNode.removeChild(c);});
            }
        }
        // --- Fonctions Secrets et Listeners (MODIFI√â pour index 4 'e' avec 3s) ---
        function addTripleClickListener(element, callback) {
             let c = 0, l = 0;
             element?.addEventListener('click', (e) => {
                 const t = Date.now();
                 if (t - l < 500) c++; else c = 1;
                 l = t;
                 if (c === 3) { callback(element); c = 0; }
             });
         }
        function handleTripleClick(element) {
            const t = translations[currentLanguage] || translations.en;
            if (!element) return;
            if (element.classList.contains('logo')) {
                restartGame();
                showTemporaryMessage(t.resetMessage);
            } else if (element.id === 'bet-pot-info') {
                 isSuccessGuaranteed = !isSuccessGuaranteed;
                 showTemporaryMessage(isSuccessGuaranteed ? t.successOnMessage : t.successOffMessage);
             } else if (element.id === 'bet-label') {
                 const select = document.getElementById('bet-amount');
                 if(select){
                     isBetLocked = !isBetLocked;
                     if (isBetLocked) {
                         lockedBetPercentage = select.value;
                         showTemporaryMessage(t.betLockedMessage(lockedBetPercentage));
                         select.disabled = true;
                     } else {
                         lockedBetPercentage = null;
                         showTemporaryMessage(t.betUnlockedMessage);
                         select.disabled = false;
                         select.value = "75";
                     }
                 }
             }
         }
        function addLongPressListener(element, duration, callback) {
             let p = null;
             const s = (e) => {
                 if (e.button === 2) return;
                 clearTimeout(p);
                 p = setTimeout(() => { if(callback) callback(); p = null; }, duration);
             };
             const c = () => { clearTimeout(p); p = null; };
             const o = { passive: true };
             element?.addEventListener('touchstart', s, o);
             element?.addEventListener('touchend', c);
             element?.addEventListener('touchcancel', c);
             element?.addEventListener('mousedown', s);
             element?.addEventListener('mouseup', c);
             element?.addEventListener('mouseleave', c);
         }
        function activatePremium() {
             if (!isPremium) {
                 isPremium = true;
                 localStorage.setItem('isPremiumVersion', 'true');
                 const t = translations[currentLanguage] || translations.en;
                 showTemporaryMessage(t.premiumUnlockedMessage);
                 updateLanguage();
             }
         }
function handleLongPressSecret(index) {
// R√©cup√®re l'objet de traduction pour la langue courante (ou l'anglais par d√©faut)
const t = translations[currentLanguage] || translations.en;
// R√©cup√®re l'√©l√©ment pour afficher des messages secrets (si utilis√©)
const secretMsgEl = document.getElementById('secret-message');
// Logique originale pour l'index 5 (case 'f' adverse) - reste inchang√©e
if (index === 5) {
// Affiche un message secret pr√©d√©fini dans la zone d√©di√©e
if (secretMsgEl) secretMsgEl.textContent = t.secretMessage;
// Vous pourriez ajouter ici un showTemporaryMessage si vous voulez un popup aussi
// showTemporaryMessage("Message secret 'f' activ√© !");
return; // Important: Sortir de la fonction apr√®s avoir trait√© l'index 5
}
// NOUVELLE LOGIQUE pour index 4 (case 'e' adverse, 3s pour d√©sactiver surbrillance)
else if (index === 4) {
toggleHighlightForScreenshot();
return;
}
// --- MODIFICATION START: Remplacement de la logique pour l'index 0 ---
else if (index === 0) { // Cas de l'appui long sur la case 'a' adverse
// 1. V√©rification indispensable : L'utilisateur doit √™tre Premium
if (!isPremium) {
showPremiumInfoModal(); // Affiche la modale d'information Premium
return; // Sortir si non-Premium
}
// 2. V√©rification : La partie est-elle en cours et y a-t-il un coup suivant ?
// On v√©rifie si 'currentGame' existe, a une longueur > 0,
// et si l'index du prochain coup est valide dans le tableau 'currentGame'.
if (currentGame && currentGame.length > 0 && currentMoveIndex + 1 < currentGame.length) {
// 3. R√©cup√©ration du caract√®re du prochain coup
const nextMoveChar = currentGame[currentMoveIndex + 1];
// 4. Affichage du prochain coup via un message temporaire
// Utilise la NOUVELLE cl√© de traduction 'revealNextMoveMessage'
// Assurez-vous que cette cl√© est ajout√©e √† l'objet 'translations' !
showTemporaryMessage(t.revealNextMoveMessage(nextMoveChar));
} else {
// 5. Cas o√π la partie est termin√©e ou non initialis√©e correctement
// On affiche le message standard de fin de partie.
// Alternativement, on pourrait cr√©er une cl√© sp√©cifique comme 'noNextMoveMessage'.
showTemporaryMessage(t.resultGameOver);
}
// IMPORTANT : Cette nouvelle logique n'a PAS modifi√© l'√©tat du jeu
// (board, scores, moveHistory, currentMoveIndex, etc.)
// et n'appelle PAS renderBoard(). C'est purement informatif.
} // --- MODIFICATION END ---
// L'ancienne logique "else if (index === 0)" qui g√©rait l'annulation (undo)
// a √©t√© compl√®tement supprim√©e et remplac√©e par le bloc ci-dessus.
}
        function addLongPressListenerForSecrets(element, index) {
             if (index === 5 || index === 0) {
                 addLongPressListener(element, 2000, () => handleLongPressSecret(index));
             } else if (index === 4) { // NOUVEAU: Pour 'e' (index 4), 3s
                 addLongPressListener(element, 3000, () => handleLongPressSecret(index));
             }
         }
        function showSecretTips() {
            if (!isPremium) { showPremiumInfoModal(); return; }
            const t = translations[currentLanguage] || translations.en;
            const secretModal = document.getElementById('secret-modal');
            const tipsTitle = document.getElementById('secret-tips-title');
            const tipsList = document.getElementById('secret-tips');
            const closeBtn = document.getElementById('secret-modal-close');
            if(secretModal && tipsTitle && tipsList && closeBtn) {
                tipsTitle.textContent = t.secretTipsTitle;
                tipsList.innerHTML = (t.secretTips || []).map(tip => `<li>${tip}</li>`).join('');
                closeBtn.textContent = t.closeButton;
                secretModal.style.display = 'block';
            }
        }
        function setupCombinedSecretListener() {
             const boardElement = document.getElementById('board'); if (!boardElement) return;
             let fPressed = false; let aPressed = false;
             let pressTimer = null;
             let targetF = null; let targetA = null;
             const clearTimer = () => { if (pressTimer) clearTimeout(pressTimer); pressTimer = null; };
             const handlePress = (event, isStartingPress) => {
                 if (!isPremium) return;
                 const holeElement = event.target.closest('.hole.player2-hole');
                 if (!holeElement) return;
                 const holeCode = holeElement.dataset.code;
                 if (holeCode === 'f') {
                     fPressed = isStartingPress;
                     targetF = isStartingPress ? holeElement : null;
                 } else if (holeCode === 'a') {
                     aPressed = isStartingPress;
                     targetA = isStartingPress ? holeElement : null;
                 } else {
                     return;
                 }
                 if (fPressed && aPressed) {
                     clearTimer();
                     pressTimer = setTimeout(() => {
                         if(fPressed && aPressed) showSecretTips();
                     }, 3000);
                 } else {
                     clearTimer();
                 }
             };
             boardElement.addEventListener('touchstart', (e) => handlePress(e, true), {passive: true});
             boardElement.addEventListener('touchend', (e) => handlePress(e, false));
             boardElement.addEventListener('touchcancel', (e) => handlePress(e, false));
             boardElement.addEventListener('mousedown', (e) => {if(e.button!==2) handlePress(e, true);});
             boardElement.addEventListener('mouseup', (e) => {if(e.button!==2) handlePress(e, false);});
             boardElement.addEventListener('mouseleave', (e) => {
                 if (e.target === targetF) handlePress(e, false);
                 if (e.target === targetA) handlePress(e, false);
             }, true);
        }
        // --- Initialisation du Jeu ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing Application...");
            isPremium = localStorage.getItem('isPremiumVersion') === 'true';
            console.log("Premium Status:", isPremium);
            document.getElementById('theme-toggle')?.addEventListener('click', () => {
                document.body.classList.toggle('dark-mode');
                renderBoard();
            });
            document.getElementById('help-btn')?.addEventListener('click', () => {
                 const t = translations[currentLanguage] || translations.en;
                 const helpTextElement = document.getElementById("help-text");
                 if (helpTextElement) {
                     const content = isPremium ? (t.helpTextPremium || t.helpTextStandard) : t.helpTextStandard;
                     helpTextElement.innerHTML = content;
                 }
                 const modal = document.getElementById('help-modal');
                 if(modal) modal.style.display = 'block';
            });
             addLongPressListener(document.getElementById('title'), 10000, activatePremium);
            const crossBtn = document.getElementById('cross-toggle-btn');
            if (crossBtn) {
                crossBtn.addEventListener('click', toggleCrossVisibility);
                addLongPressListener(crossBtn, 3000, toggleAides);
            }
             document.querySelectorAll('.logo, #bet-pot-info, #bet-label').forEach(element => {
                if(element) addTripleClickListener(element, handleTripleClick);
            });
            setupCombinedSecretListener();
            const langSelect = document.getElementById("language-select");
            if(langSelect) langSelect.addEventListener('change', updateLanguage);
            const levelSelect = document.getElementById("level-select");
            if(levelSelect) levelSelect.addEventListener('change', changeLevel);
            loadGameRecords();
            board = initialBoard();
            scores = initialScores();
            currentGameIndex = 0;
            currentGame = games[currentGameIndex] ? games[currentGameIndex].split('') : [];
            moveHistory = [{ board: JSON.parse(JSON.stringify(board)), scores: JSON.parse(JSON.stringify(scores)), moveCode: null }];
            console.log("Initial board state set.");
            currentLanguage = langSelect ? (langSelect.value || "fr") : "fr";
            updateLanguage();
            console.log("Initialization complete. Current Language:", currentLanguage);
        });
        document.addEventListener("DOMContentLoaded", function() {
            // Votre code d'initialisation existant
            console.log("Initialization complete. Current Language:", currentLanguage);
           
            // Fonction pour d√©tecter iOS
            function isIOS() {
                return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            }
           
            // Fonction pour v√©rifier si l'application est d√©j√† install√©e (en mode standalone)
            function isInStandaloneMode() {
                return ('standalone' in window.navigator) && (window.navigator.standalone);
            }
           
            // Fonction pour afficher la banni√®re d'installation
            function showInstallBanner() {
                // Seulement pour iOS et si l'app n'est pas d√©j√† install√©e
                if (isIOS() && !isInStandaloneMode()) {
                    // Cr√©er la banni√®re si elle n'existe pas d√©j√†
                    if (!document.getElementById('ios-install-banner')) {
                        const banner = document.createElement('div');
                        banner.id = 'ios-install-banner';
                        banner.style.cssText = `
                            position: fixed;
                            bottom: 0;
                            left: 0;
                            right: 0;
                            padding: 15px;
                            background-color: #f8f9fa;
                            border-top: 1px solid #dee2e6;
                            text-align: center;
                            z-index: 9999;
                            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
                        `;
                       
                        banner.innerHTML = `
                            <p style="margin: 0 0 10px 0;"><strong>Installez cette application sur votre iPhone</strong></p>
                            <p style="margin: 0 0 10px 0;">1. Appuyez sur <svg style="width: 20px; height: 20px; vertical-align: middle;" viewBox="0 0 24 24"><path fill="currentColor" d="M18,16.08C17.24,16.08 16.56,16.38 16.04,16.85L8.91,12.7C8.96,12.47 9,12.24 9,12C9,11.76 8.96,11.53 8.91,11.3L15.96,7.19C16.5,7.69 17.21,8 18,8A3,3 0 0,0 21,5A3,3 0 0,0 18,2A3,3 0 0,0 15,5C15,5.24 15.04,5.47 15.09,5.7L8.04,9.81C7.5,9.31 6.79,9 6,9A3,3 0 0,0 3,12A3,3 0 0,0 6,15C6.79,15 7.5,14.69 8.04,14.19L15.16,18.34C15.11,18.55 15.08,18.77 15.08,19C15.08,20.61 16.39,21.91 18,21.91C19.61,21.91 20.92,20.61 20.92,19A2.92,2.92 0 0,0 18,16.08Z" /></svg> puis sur "Sur l'√©cran d'accueil"</p>
                            <p style="margin: 0;">2. L'application sera alors disponible comme une app native !</p>
                            <button id="close-banner" style="margin-top: 10px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Fermer</button>
                        `;
                       
                        document.body.appendChild(banner);
                       
                        // Ajouter un √©v√©nement pour fermer la banni√®re
                        document.getElementById('close-banner').addEventListener('click', function() {
                            document.getElementById('ios-install-banner').style.display = 'none';
                           
                            // Stocker l'info que l'utilisateur a ferm√© la banni√®re
                            localStorage.setItem('iosBannerClosed', 'true');
                        });
                    }
                }
            }
           
            // V√©rifier si la banni√®re a d√©j√† √©t√© ferm√©e
            function checkBannerStatus() {
                return localStorage.getItem('iosBannerClosed') === 'true';
            }
           
            // Afficher la banni√®re apr√®s un d√©lai
            if (!checkBannerStatus()) {
                setTimeout(showInstallBanner, 3000); // Afficher apr√®s 3 secondes
            }
        });
    </script>
</body>
</html>
